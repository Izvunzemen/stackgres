#!/bin/sh

. "$SPEC_PATH/abstract/backup"
. "$SPEC_PATH/abstract/dbops-restart"

e2e_test_install() {
  install_minio

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 2

  deploy_curl_pod "$CLUSTER_NAMESPACE"

  wait_pods_running "$CLUSTER_NAMESPACE" 4
  wait_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE"
}

e2e_test() {
  run_test "Backup Cron Job should have a security context" check_cron_job_security_context

  run_test "Checking that backup is working" check_backup_is_working

  run_test "Checking single backup job is running at a time" check_single_backup_job

  run_test "Checking that backup retention is working" check_backup_retention_is_working

  run_test "Checking that backup is working after killing storage provider service" check_backup_after_kill_storage_provider_service

  run_test "Checking that automatic backup is working after a restart" check_automatic_backup_after_restart

  run_test "Checking that manual backup is working after a restart" check_manual_backup_after_restart

  run_test "Checking that backups aren't being deleted after the cluster is deleted" check_backup_not_deleted_after_cluster
}

check_cron_job_security_context() {
  local RUN_AS_NON_ROOT
  RUN_AS_NON_ROOT="$(kubectl get cronjobs.batch -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"-backup -o jsonpath='{.spec.jobTemplate.spec.template.spec.securityContext.runAsNonRoot}')"
  assert_string_equal "true" "$RUN_AS_NON_ROOT"
}


check_backup_is_working() {
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"*/1 * * * *"}]'

  check_backup 0
}

check_backup_retention_is_working() {
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"*/1 * * * *"}]'

  check_backup_retention 0
}

check_backup_after_kill_storage_provider_service() {
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"*/1 * * * *"}]'

  kubectl delete sgbackup -n "$CLUSTER_NAMESPACE" --all

  kubectl get pod -n "$CLUSTER_NAMESPACE" -o name | grep "^pod/$CLUSTER_NAME-minio-" \
    | xargs -r -n 1 -I % kubectl delete -n "$CLUSTER_NAMESPACE" %

  kubectl wait --timeout="$((E2E_TIMEOUT * 2))s" -n "$CLUSTER_NAMESPACE" \
    deployment/"$CLUSTER_NAME-minio" --for=condition=Available

  check_backup 0
}

check_automatic_backup_after_restart() {
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"0 5 31 2 *"}]'

  generate_mock_data "$CLUSTER_NAME"
  check_mock_data_samehost "$CLUSTER_NAME"
  check_mock_data_replication "$CLUSTER_NAME"
  run_query -p 5432 -i 0 -d "test" \
    -q "CREATE TABLE data AS SELECT i, 'this is a long text number ' || i FROM generate_series(1, 100000) as i"

  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"*/3 * * * *"}]'

  check_automatic_backup 0

  DBOPS_NAME="$(get_sgdbops_name restart)"
  cat << EOF | kubectl create -f -
apiVersion: stackgres.io/v1
kind: SGDbOps
metadata:
  name: $DBOPS_NAME
  namespace: $CLUSTER_NAMESPACE
spec:
  sgCluster: $CLUSTER_NAME
  op: restart
  restart:
    method: InPlace
EOF

  check_restart

  local PRIMARY_NODE
  PRIMARY_NODE="$(kubectl get pod -n "$CLUSTER_NAMESPACE" \
    -l app=StackGresCluster,cluster-name=backup,role=master -o name)"
  PRIMARY_NODE="$(printf '%s' "$PRIMARY_NODE" | cut -d - -f 2)"

  check_wal_archive "$PRIMARY_NODE"

  check_automatic_backup "$PRIMARY_NODE"

  check_timelines

  check_control_data

  kubectl delete sgdbops -n "$CLUSTER_NAMESPACE" "$DBOPS_NAME"
}

check_manual_backup_after_restart() {
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"0 5 31 2 *"}]'

  kubectl delete sgbackup -n "$CLUSTER_NAMESPACE" --all

  local BACKUP_NAME
  BACKUP_NAME="$(get_sgbackup_name "${CLUSTER_NAME}-$(shuf -i 0-65535 -n 1)")"
  local BACKUP_2_NAME
  BACKUP_2_NAME="$(get_sgbackup_name "${CLUSTER_NAME}-$(shuf -i 0-65535 -n 1)")"

  generate_mock_data "$CLUSTER_NAME"
  check_mock_data_samehost "$CLUSTER_NAME"
  check_mock_data_replication "$CLUSTER_NAME"
  run_query -p 5432 -i 0 -d "test" \
    -q "CREATE TABLE data AS SELECT i, 'this is a long text number ' || i FROM generate_series(1, 100000) as i"

  check_manual_backup_only 0 "$BACKUP_NAME"

  DBOPS_NAME="$(get_sgdbops_name restart)"
  cat << EOF | kubectl create -f -
apiVersion: stackgres.io/v1
kind: SGDbOps
metadata:
  name: $DBOPS_NAME
  namespace: $CLUSTER_NAMESPACE
spec:
  sgCluster: $CLUSTER_NAME
  op: restart
  restart:
    method: InPlace
EOF

  check_restart

  local PRIMARY_NODE
  PRIMARY_NODE="$(kubectl get pod -n "$CLUSTER_NAMESPACE" \
    -l app=StackGresCluster,cluster-name=backup,role=master -o name)"
  PRIMARY_NODE="$(printf '%s' "$PRIMARY_NODE" | cut -d - -f 2)"

  check_wal_archive "$PRIMARY_NODE"

  check_manual_backup_only "$PRIMARY_NODE" "$BACKUP_2_NAME"

  check_timelines

  check_control_data

  kubectl delete sgdbops -n "$CLUSTER_NAMESPACE" "$DBOPS_NAME"
}

check_backup_not_deleted_after_cluster() {
  kubectl delete sgcluster -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"

  wait_pods_terminated "$CLUSTER_NAMESPACE" 2

  BACKUPS_COUNT="$(kubectl get sgbackup -n "$CLUSTER_NAMESPACE" -o json | jq '.items | length')"

  assert_greater_than 0 "$BACKUPS_COUNT"
}

