#!/bin/sh

. "$SPEC_PATH/abstract/backup"

e2e_test_install() {
  if [ "$E2E_ENV" = "kind" ]
  then
    cat << EOF > "$LOG_PATH/minio-affinity.yaml"
minio:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
            - key: "kubernetes.io/hostname"
              operator: "In"
              values: [ "${KIND_NAME}-worker", "${KIND_NAME}-control-plane" ]
EOF
  else
    echo -n > "$LOG_PATH/minio-affinity.yaml"
  fi
  if [ "$E2E_ENV" = "minishift" ]
  then
    eval "$(minishift oc-env)"
    oc adm policy add-scc-to-user anyuid -n "$CLUSTER_NAMESPACE" -z "$CLUSTER_NAME-minio"
  fi

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 2 \
    -f "$LOG_PATH/minio-affinity.yaml"

  deploy_curl_pod "$CLUSTER_NAMESPACE"

  wait_pods_running "$CLUSTER_NAMESPACE" 4

  # Avoid backups before waiting for pods (since backup pods could biase the wait)
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"*/1 * * * *"}]'
}

e2e_test() {
  run_test "Backup Cron Job should have a security context" check_cron_job_security_context

  run_test "Checking that backup is working before switchover" check_backup_before_switchover

  run_test "Checking single backup job is running at a time" check_single_backup_job

  run_test "Checking that backup retention is working before switchover" check_backup_retention_before_switchover

  run_test "Checking that switchover is working" check_switchover

  run_test "Checking that backup is working after switchover" check_backup_after_switchover

  run_test "Checking that backup is working after killing storage provider service" check_backup_after_kill_storage_provider_service

  run_test "Checking that backups aren't being deleted after the cluster is deleted" check_backup_not_delect_after_cluster
}

check_cron_job_security_context() {
  local RUN_AS_NON_ROOT=$(kubectl get cronjobs.batch -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"-backup -o jsonpath='{.spec.jobTemplate.spec.template.spec.securityContext.runAsNonRoot}')
  assert_string_equal "true" "$RUN_AS_NON_ROOT"
}


check_backup_before_switchover() {
  check_backup 0
}

check_backup_retention_before_switchover() {
  check_backup_retention 0
}

check_backup_after_switchover() {
  check_backup 1
}

check_backup_after_kill_storage_provider_service() {
  kubectl get pod -n "$CLUSTER_NAMESPACE" -o name | grep "^pod/$CLUSTER_NAME-minio-" \
    | xargs -r -n 1 -I % kubectl delete -n "$CLUSTER_NAMESPACE" %

  kubectl wait --timeout="$((E2E_TIMEOUT * 2))s" -n "$CLUSTER_NAMESPACE" \
    deployment/"$CLUSTER_NAME-minio" --for=condition=Available

  check_backup 1
}

check_backup_not_delect_after_cluster() {
  
  kubectl delete sgcluster -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"

  wait_pods_terminated "$CLUSTER_NAMESPACE" 2

  BACKUPS_COUNT=$(kubectl get sgbackup -n "$CLUSTER_NAMESPACE" -o json | jq '.items | length')

  assert_greater_than 0 $BACKUPS_COUNT
}

