#!/bin/sh

e2e_test_install() {
  NODE_LABEL_KEY=$(ramdom_string)
  NODE_LABEL_VALUE=$(ramdom_string)
  NODE_AFFINITY_VALUE=$(ramdom_string)
  NODE_AFFINITY_OPERATOR=$(ramdom_string)
  NODE_AFFINITY_KEY="yyyyyyyyyyy"

  kubectl create namespace "$CLUSTER_NAMESPACE"

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 1 \
    --set-string "cluster.pods.scheduling.nodeSelector.$NODE_LABEL_KEY=$NODE_LABEL_VALUE" \
    --set-string "cluster.pods.scheduling.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms.0.matchExpressions.0.key=$NODE_AFFINITY_KEY" \
    --set-string "cluster.pods.scheduling.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms.0.matchExpressions.0.operator=$NODE_AFFINITY_OPERATOR" \
    --set-string "cluster.pods.scheduling.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms.0.matchExpressions.0.values.0=$NODE_AFFINITY_VALUE" \
    --set-string cluster.distributedLogs.sgDistributedLogs=distributedlogs \
    --set distributedLogs.enabled=true \
    --set-string "distributedLogs.scheduling.nodeSelector.$NODE_LABEL_KEY=$NODE_LABEL_VALUE" 
}

e2e_test_uninstall() {
  helm_cleanup_chart "$CLUSTER_NAME" "$CLUSTER_NAMESPACE"

  k8s_async_cleanup_namespace "$CLUSTER_NAMESPACE"
}

e2e_test() {
  run_test "sgcluster has specified node affinity" check_sgcluster_has_node_affinity
  #run_test "sgcluster's StatefulSet has specified node affinity" check_sgcluster_sts_has_node_affinity
}

check_sgcluster_has_node_affinity() {
  if [ "$(kubectl get sgcluster -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" \
    --template "{{ (index (index .spec.pods.scheduling.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms 0).matchExpressions 0).key }}")" \
      = "$NODE_AFFINITY_KEY" ]
    then
      echo "SUCCESS. sgcluster has the configured node affinity required during execution key match"
    else
      echo "FAIL. sgcluster has not the configured node affinity required during execution key match"
      return 1
    fi  

  if [ "$(kubectl get sgcluster -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" \
    --template "{{ (index (index .spec.pods.scheduling.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms 0).matchExpressions 0).operator }}")" \
      = "$NODE_AFFINITY_OPERATOR" ]
    then
      echo "SUCCESS. sgcluster has the configured node affinity required during execution operator match"
    else
      echo "FAIL. sgcluster has not the configured node affinity required during execution operator match"
      return 1
    fi  

  if [ "$(kubectl get sgcluster -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" \
    --template "{{ (index (index (index .spec.pods.scheduling.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms 0).matchExpressions 0).values 0) }}")" \
      = "$NODE_AFFINITY_VALUE" ]
    then
      echo "SUCCESS. sgcluster has the configured node affinity required during execution values match"
    else
      echo "FAIL. sgcluster has not the configured node affinity required during execution values match"
      return 1
    fi  
}

check_sgcluster_sts_has_node_affinity(){
  echo "Waiting for sts with node affinity"
  try_function wait_until eval "$(cat << 'EOF'
[ "$(kubectl get sts -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" \
  --template "{{ .spec.template.spec.affinity }}")" \
  = "yyyyyyyyyyy" ]
EOF
    )"
  if "$RESULT"
  then
    echo "SUCCESS. sgcluster's StatefulSet has the configured node affinity required during execution key match"
  else
    echo "FAIL. sgcluster's StatefulSet has not the configured node affinity required during execution key match"
    return 1
  fi
 
}