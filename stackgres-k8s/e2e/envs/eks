#!/bin/sh

K8S_EKS_NAME="${K8S_EKS_NAME:-stackgres-e2e}"
K8S_EKS_REGION="${K8S_EKS_REGION:-us-east-1}"
K8S_EKS_NODE_TYPE="${K8S_EKS_NODE_TYPE:-m5.large}"
K8S_EKS_DISK_SIZE="${K8S_EKS_DISK_SIZE:-20}"
K8S_EKS_OPTS="$K8S_EKS_OPTS"
K8S_EKS_BUCKET_NAME="${K8S_EKS_BUCKET_NAME:-stackgres-e2e-bucket}"
E2E_USE_INTERMIDIATE_PRIVATE_REPO=true

export K8S_EKS_NAME K8S_VERSION K8S_EKS_REGION K8S_EKS_NODE_LOCATIONS K8S_EKS_NODE_TYPE K8S_EKS_OPTS E2E_USE_INTERMIDIATE_PRIVATE_REPO

get_k8s_env_version() {
  echo "eksctl version $(eksctl version)"
  echo
}

reuse_k8s() {
  if ! eksctl get cluster --name "$K8S_EKS_NAME" --region "$K8S_EKS_REGION" 2>&1 \
    | grep "^$K8S_EKS_NAME" | grep -q "ACTIVE"
  then
    echo "Can not reuse eks environment $K8S_EKS_NAME"
    exit 1
  fi

  echo "Reusing eks environment $K8S_EKS_NAME"

  aws eks update-kubeconfig --name "$K8S_EKS_NAME" --region "$K8S_EKS_REGION"

  echo "...done"
}

reset_k8s() {
  echo "Setting up eks environment $K8S_EKS_NAME..."

  if ! get_k8s_versions | grep -qxF "$K8S_VERSION"
  then
    >&2 echo "EKS does not support Kubernetes $K8S_VERSION but only one of: $(get_k8s_versions | tr '\n' ' ')"
    return 1
  fi

  delete_k8s
  eksctl create cluster --name "$K8S_EKS_NAME" \
    --region "$K8S_EKS_REGION" \
    --node-type "$K8S_EKS_NODE_TYPE" \
    --node-volume-size "$K8S_EKS_DISK_SIZE" \
    --nodes 3 \
    --version "$(echo "$K8S_VERSION" | cut -d . -f 1-2)" \
    $K8S_EKS_OPTS

  aws s3 mb "s3://$K8S_EKS_BUCKET_NAME/"

  echo "...done"
}

delete_k8s() {
  echo "Deleting eks environment $K8S_EKS_NAME..."

  if eksctl get cluster --name "$K8S_EKS_NAME" --region "$K8S_EKS_REGION" 2>&1 \
    | grep "^$K8S_EKS_NAME" | grep -q "ACTIVE"
  then
    eksctl delete cluster --wait --name "$K8S_EKS_NAME" --region "$K8S_EKS_REGION" || true
  fi
  
  aws ec2 describe-volumes --region "$K8S_EKS_REGION" --filters "Name=tag-key,Values=kubernetes.io/cluster/$K8S_EKS_NAME" \
    | jq -r '.Volumes[].VolumeId' \
    | while read -r VOLUME_ID
      do
        aws ec2 detach-volume --force --region "$K8S_EKS_REGION" --volume-id "$VOLUME_ID" || true
      done
  
  aws ec2 describe-volumes --region "$K8S_EKS_REGION" --filters "Name=tag-key,Values=kubernetes.io/cluster/$K8S_EKS_NAME" \
    | jq -r '.Volumes[].VolumeId' \
    | while read -r VOLUME_ID
      do
        aws ec2 delete-volume --region "$K8S_EKS_REGION" --volume-id "$VOLUME_ID" || true
      done

  if aws s3 ls | cut -d ' ' -f 3 | grep -q "$K8S_EKS_BUCKET_NAME"
  then
    aws s3 rb "s3://$K8S_EKS_BUCKET_NAME/" --force
  fi

  aws cloudformation describe-stacks \
    | jq -r '.Stacks[]|select(.Tags|any(.Key == "alpha.eksctl.io/cluster-name" and .Value == "$K8S_EKS_NAME")).StackName' \
    | while read -r STACK_NAME
      do
        aws cloudformation delete-stack --stack-name "$STACK_NAME" || true
      done

  echo "...done"
}

load_image_k8s() {
  echo "Cannot load images directly to k8s in a eks environment, skpping"
}

operator_pull_policy() {
  echo Always
}

get_k8s_versions() {
  cat << EOF
1.21.2
1.20.7
1.19.8
1.18.16
1.17.17
EOF
}

excluded_customresourcedefinitions() {
  echo '.*\.aws'
  echo '.*\.amazonaws\.com'
}

excluded_clusterroles() {
  echo 'eks:.*'
  echo 'aws-node'
  echo 'vpc-resource-controller-role'
}

excluded_clusterrolebindings() {
  echo 'eks:.*'
  echo 'aws-node'
  echo 'vpc-resource-controller-rolebinding'
}

excluded_podsecuritypolicies() {
  echo 'eks\.privileged'
}

excluded_validatingwebhookconfigurations() {
  echo "vpc-resource-validating-webhook"
}

excluded_mutatingwebhookconfigurations() {
  echo "vpc-resource-mutating-webhook"
  echo "pod-identity-webhook"
}
