#!/bin/sh

reuse_k8s() {
  if ! minikube status > /dev/null 2>&1 \
    || ! kubectl cluster-info > /dev/null 2>&1
  then
    echo "Can not reuse minikube environment"
    reset_k8s
    return
  fi

  echo "Reusing minikube environment"
}

reset_k8s() {
  echo "Setting up minikube environment..."

  minikube delete || true

  MINUKUBE_PARALLELISM="${E2E_PARALLELISM:-2}"

  local MEMORY=$(printf "%sGB" "$MINUKUBE_PARALLELISM")

  minikube start --kubernetes-version $K8S_VERSION --memory "$MEMORY" --cpus $MINUKUBE_PARALLELISM

  echo "...done"
}

delete_k8s() {
  echo "Deleting minikube environment..."

  minikube delete || true

  echo "...done"
}

load_operator_k8s() {
  echo "Loading operator image $IMAGE_NAME in minikube environemnt..."

  local IMAGE_USER="$(dirname "$IMAGE_NAME")"
  local IMAGE_MINIKUBE_NAME="$(basename "$IMAGE_NAME"|tr ':' '_')"
  mkdir -p "$HOME/.minikube/cache/images/$IMAGE_USER"
  docker save "$IMAGE_NAME" > "$HOME/.minikube/cache/images/$IMAGE_USER/$IMAGE_MINIKUBE_NAME"
  minikube cache add "$IMAGE_NAME"
  if [ "$USE_MINIKUBE_CRIO" = true ]
  then
    minikube ssh -- su root -l -c "'podman tag \"localhost/$IMAGE_NAME\" \"docker.io/$IMAGE_NAME\"'"
  fi

  echo "...done"
}

get_k8s_versions() {
  cat << EOF
1.11.10
1.12.10
1.13.12
1.14.10
1.14.9
1.15.11
1.15.6
1.16.3
1.16.9
1.17.5
1.18.2
EOF
}
