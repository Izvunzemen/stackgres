{
  "apiVersion": "v1",
  "data": {
    "create-backup.sh": "#!/bin/sh\n\nLOCK_RESOURCE=\"cronjob.batch\"\nLOCK_RESOURCE_NAME=\"$CRONJOB_NAME\"\n\n. \"$LOCAL_BIN_SHELL_UTILS_PATH\"\n\nrun() {\n  set -e\n\n  acquire_lock \u003e /tmp/try-lock 2\u003e\u00261\n  echo \"Lock acquired\"\n  maintain_lock \u003e\u003e /tmp/try-lock 2\u003e\u00261 \u0026\n  TRY_LOCK_PID=$!\n\n  reconcile_backups \u0026\n  PID=$!\n\n  set +e\n  (\n  set +x\n  while (kill -0 \"$PID\" \u0026\u0026 kill -0 \"$TRY_LOCK_PID\") 2\u003e/dev/null\n  do\n    true\n  done\n  )\n\n  if kill -0 \"$PID\" 2\u003e/dev/null\n  then\n    kill_with_childs \"$PID\"\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Lock lost:\\n'\"$(cat /tmp/try-lock | to_json_string)\"'\"}\n      ]'\n    cat /tmp/try-lock\n    echo \"Lock lost\"\n    return 1\n  else\n    kill_with_childs \"$TRY_LOCK_PID\"\n    release_lock \u003e\u003e /tmp/try-lock 2\u003e\u00261\n    echo \"Lock released\"\n    wait \"$PID\"\n    EXIT_CODE=\"$?\"\n    if [ \"$EXIT_CODE\" != 0 ]\n    then\n      cat /tmp/backup-push\n      echo \"Backup failed\"\n      [ -n \"$SCHEDULED_BACKUP_KEY\" ] || sleep 20\n      return 1\n    fi\n  fi\n}\n\nreconcile_backups() {\n  set -e\n  get_backup_crs\n\n  if [ -n \"$SCHEDULED_BACKUP_KEY\" ]\n  then\n    BACKUP_NAME=\"${CLUSTER_NAME}-$(date +%Y-%m-%d-%H-%M-%S --utc)\"\n  fi\n\n  BACKUP_CONFIG_RESOURCE_VERSION=\"$(kubectl get \"$BACKUP_CONFIG_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CONFIG\" --template='{{ .metadata.resourceVersion }}')\"\n  BACKUP_ALREADY_COMPLETED=false\n  create_or_update_backup_cr\n  if [ \"$BACKUP_ALREADY_COMPLETED\" = \"true\" ]\n  then\n    echo \"Already completed backup. Nothing to do!\"\n    return\n  fi\n\n  CURRENT_BACKUP_CONFIG=\"$(kubectl get \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" \\\n    --template=\"{{ .status.sgBackupConfig.storage }}\")\"\n\n  set +e\n  echo \"Retrieving primary and replica\"\n  get_primary_and_replica_pods\n\n  echo \"Performing backup\"\n  do_backup\n  echo \"Backup completed\"\n\n  echo \"Extracting pg_controldata\"\n  extract_controldata\n  if [ \"$?\" = 0 ]\n  then\n    echo \"Extraction of pg_controldata completed\"\n  else\n    echo \"Extraction of pg_controldata failed\"\n  fi\n\n  echo \"Retain backups\"\n  retain_backups\n  if [ \"$?\" = 0 ]\n  then\n    echo \"Reconciliation of backups completed\"\n  else\n    echo \"Reconciliation of backups failed\"\n  fi\n\n  echo \"Listing existing backups\"\n  list_backups\n  if [ \"$?\" != 0 ]\n  then\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Backup can not be listed after creation '\"$(cat /tmp/backup-list | to_json_string)\"'\"}\n      ]'\n    cat /tmp/backup-list\n    echo \"Backups can not be listed after creation\"\n    return 1\n  fi\n  cat /tmp/backup-list | tr -d '[]' | sed 's/},{/}|{/g' | tr '|' '\\n' \\\n    | grep '\"backup_name\":\"'\"$CURRENT_BACKUP_NAME\"'\"' | tr -d '{}\"' | tr ',' '\\n' \u003e /tmp/current-backup\n  if [ \"$BACKUP_CONFIG_RESOURCE_VERSION\" != \"$(kubectl get \"$BACKUP_CONFIG_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CONFIG\" --template='{{ .metadata.resourceVersion }}')\" ]\n  then\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Backup configuration '\"$BACKUP_CONFIG\"' changed during backup\"}\n      ]'\n    cat /tmp/backup-list\n    echo \"Backup configuration '$BACKUP_CONFIG' changed during backup\"\n    return 1\n  elif ! grep -q \"^backup_name:${CURRENT_BACKUP_NAME}$\" /tmp/current-backup\n  then\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Backup '\"$CURRENT_BACKUP_NAME\"' was not found after creation\"}\n      ]'\n    cat /tmp/backup-list\n    echo \"Backup '$CURRENT_BACKUP_NAME' was not found after creation\"\n    return 1\n  fi\n\n  echo \"Updating backup CR as completed\"\n  set_backup_completed\n  echo \"Backup CR updated as completed\"\n\n  echo \"Reconcile backup CRs\"\n  reconcile_backup_crs\n  echo \"Reconciliation of backup CRs completed\"\n}\n\nget_backup_crs() {\n  BACKUP_CR_TEMPLATE=\"{{ range .items }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}{{ .spec.sgCluster }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ .metadata.name }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ with .status.process.status }}{{ . }}{{ end }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ with .status.internalName }}{{ . }}{{ end }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ with .status.process.jobPod }}{{ . }}{{ end }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ with .metadata.labels }}{{ with index . \\\"$SCHEDULED_BACKUP_KEY\\\" }}{{ . }}{{ end }}{{ end }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ if .spec.managedLifecycle }}true{{ else }}false{{ end }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}:{{ if .status.process.managedLifecycle }}true{{ else }}false{{ end }}\"\n  BACKUP_CR_TEMPLATE=\"${BACKUP_CR_TEMPLATE}{{ printf \"'\"\\n\"'\" }}{{ end }}\"\n  kubectl get \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \\\n    --template=\"$BACKUP_CR_TEMPLATE\" \u003e /tmp/all-backups\n  grep \"^$CLUSTER_NAME:\" /tmp/all-backups \u003e /tmp/backups || true\n}\n\ncreate_or_update_backup_cr() {\n  BACKUP_CONFIG_YAML=$(cat \u003c\u003c BACKUP_CONFIG_YAML_EOF\n    baseBackups:\n      compression: \"{{ .spec.baseBackups.compression }}\"\n    storage:\n      type: \"{{ .spec.storage.type }}\"\n      {{- with .spec.storage.s3 }}\n      s3:\n        bucket: \"{{ .bucket }}\"\n        {{ with .path }}path: \"{{ . }}\"{{ end }}\n        awsCredentials:\n          secretKeySelectors:\n            accessKeyId:\n              key: \"{{ .awsCredentials.secretKeySelectors.accessKeyId.key }}\"\n              name: \"{{ .awsCredentials.secretKeySelectors.accessKeyId.name }}\"\n            secretAccessKey:\n              key: \"{{ .awsCredentials.secretKeySelectors.secretAccessKey.key }}\"\n              name: \"{{ .awsCredentials.secretKeySelectors.secretAccessKey.name }}\"\n        {{ with .region }}region: \"{{ . }}\"{{ end }}\n        {{ with .storageClass }}storageClass: \"{{ . }}\"{{ end }}\n      {{- end }}\n      {{- with .spec.storage.s3Compatible }}\n      s3Compatible:\n        bucket: \"{{ .bucket }}\"\n        {{ with .path }}path: \"{{ . }}\"{{ end }}\n        awsCredentials:\n          secretKeySelectors:\n            accessKeyId:\n              key: \"{{ .awsCredentials.secretKeySelectors.accessKeyId.key }}\"\n              name: \"{{ .awsCredentials.secretKeySelectors.accessKeyId.name }}\"\n            secretAccessKey:\n              key: \"{{ .awsCredentials.secretKeySelectors.secretAccessKey.key }}\"\n              name: \"{{ .awsCredentials.secretKeySelectors.secretAccessKey.name }}\"\n        {{ with .region }}region: \"{{ . }}\"{{ end }}\n        {{ with .endpoint }}endpoint: \"{{ . }}\"{{ end }}\n        {{ with .enablePathStyleAddressing }}enablePathStyleAddressing: {{ . }}{{ end }}\n        {{ with .storageClass }}storageClass: \"{{ . }}\"{{ end }}\n      {{- end }}\n      {{- with .spec.storage.gcs }}\n      gcs:\n        bucket: \"{{ .bucket }}\"\n        {{ with .path }}path: \"{{ . }}\"{{ end }}\n        gcpCredentials:\n          {{- if .gcpCredentials.fetchCredentialsFromMetadataService }}\n          fetchCredentialsFromMetadataService: true\n          {{- else }}\n          secretKeySelectors:\n            serviceAccountJSON:\n              key: \"{{ .gcpCredentials.secretKeySelectors.serviceAccountJSON.key }}\"\n              name: \"{{ .gcpCredentials.secretKeySelectors.serviceAccountJSON.name }}\"\n          {{- end }}\n      {{- end }}\n      {{- with .spec.storage.azureBlob }}\n      azureBlob:\n        bucket: \"{{ .bucket }}\"\n        {{ with .path }}path: \"{{ . }}\"{{ end }}\n        azureCredentials:\n          secretKeySelectors:\n            storageAccount:\n              key: \"{{ .azureCredentials.secretKeySelectors.storageAccount.key }}\"\n              name: \"{{ .azureCredentials.secretKeySelectors.storageAccount.name }}\"\n            accessKey:\n              key: \"{{ .azureCredentials.secretKeySelectors.accessKey.key }}\"\n              name: \"{{ .azureCredentials.secretKeySelectors.accessKey.name }}\"\n      {{- end }}\nBACKUP_CONFIG_YAML_EOF\n  )\nBACKUP_STATUS_YAML=$(cat \u003c\u003c BACKUP_STATUS_YAML_EOF\nstatus:\n  process:\n    status: \"$BACKUP_PHASE_RUNNING\"\n    jobPod: \"$POD_NAME\"\n  sgBackupConfig:\n$(kubectl get \"$BACKUP_CONFIG_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CONFIG\" --template=\"$BACKUP_CONFIG_YAML\")\nBACKUP_STATUS_YAML_EOF\n  )\n\n  if ! kubectl get \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" -o name \u003e/dev/null 2\u003e\u00261\n  then\n    echo \"Creating backup CR\"\n    cat \u003c\u003c EOF | kubectl create -f - -o yaml\napiVersion: $BACKUP_CRD_APIVERSION\nkind: $BACKUP_CRD_KIND\nmetadata:\n  namespace: \"$CLUSTER_NAMESPACE\"\n  name: \"$BACKUP_NAME\"\n  annotations:\n    $SCHEDULED_BACKUP_KEY: \"$RIGHT_VALUE\"\nspec:\n  sgCluster: \"$CLUSTER_NAME\"\n  managedLifecycle: true\n$BACKUP_STATUS_YAML\nEOF\n  else\n    if ! kubectl get \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --template=\"{{ .status.process.status }}\" \\\n      | grep -q \"^$BACKUP_PHASE_COMPLETED$\"\n    then\n      echo \"Updating backup CR\"\n      kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" -o yaml --type merge --patch \"$(\n        (\n          kubectl get \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" -o yaml\n          echo \"$BACKUP_STATUS_YAML\"\n        ) | kubectl create --dry-run=client -f - -o json)\"\n    else\n      BACKUP_ALREADY_COMPLETED=true\n    fi\n  fi\n}\n\nget_primary_and_replica_pods() {\n  kubectl get pod -n \"$CLUSTER_NAMESPACE\" -l \"${PATRONI_CLUSTER_LABELS},${PATRONI_ROLE_KEY}=${PATRONI_PRIMARY_ROLE}\" -o name \u003e /tmp/current-primary\n  kubectl get pod -n \"$CLUSTER_NAMESPACE\" -l \"${PATRONI_CLUSTER_LABELS},${PATRONI_ROLE_KEY}=${PATRONI_REPLICA_ROLE}\" -o name | head -n 1 \u003e /tmp/current-replica-or-primary\n  if [ ! -s /tmp/current-primary ]\n  then\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Unable to find primary, backup aborted\"}\n      ]'\n    kubectl get pod -n \"$CLUSTER_NAMESPACE\" -l \"${PATRONI_CLUSTER_LABELS}\" \u003e\u00262\n    echo \u003e /tmp/backup-push\n    echo \"Unable to find primary, backup aborted\" \u003e\u003e /tmp/backup-push\n    exit 1\n  fi\n\n  if [ ! -s /tmp/current-replica-or-primary ]\n  then\n    cat /tmp/current-primary \u003e /tmp/current-replica-or-primary\n    echo \"Primary is $(cat /tmp/current-primary)\"\n    echo \"Replica not found, primary will be used for cleanups\"\n  else\n    echo \"Primary is $(cat /tmp/current-primary)\"\n    echo \"Replica is $(cat /tmp/current-replica-or-primary)\"\n  fi\n}\n\ndo_backup() {\n  cat \u003c\u003c EOF | kubectl exec -i -n \"$CLUSTER_NAMESPACE\" \"$(cat /tmp/current-primary)\" -c \"$PATRONI_CONTAINER_NAME\" \\\n    -- sh -e $SHELL_XTRACE \u003e /tmp/backup-push 2\u003e\u00261\nexec-with-env \"$BACKUP_ENV\" \\\\\n  -- wal-g backup-push \"$PG_DATA_PATH\" -f $([ \"$BACKUP_IS_PERMANENT\" = true ] \u0026\u0026 echo '-p' || true)\nEOF\n  if [ \"$?\" != 0 ]\n  then\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Backup failed: '\"$(cat /tmp/backup-push | to_json_string)\"'\"}\n      ]'\n    exit 1\n  fi\n  CURRENT_BACKUP_NAME=\n  if grep -q \" Wrote backup with name \" /tmp/backup-push\n  then\n    CURRENT_BACKUP_NAME=\"$(grep \" Wrote backup with name \" /tmp/backup-push | sed 's/.* \\([^ ]\\+\\)$/\\1/')\"\n  fi\n  if [ -z \"$CURRENT_BACKUP_NAME\" ]\n  then\n    kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch '[\n      {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_FAILED\"'\"},\n      {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"Backup name not found in backup-push log:\\n'\"$(cat /tmp/backup-push | to_json_string)\"'\"}\n      ]'\n    cat /tmp/backup-push\n    echo \"Backup name not found in backup-push log\"\n    exit 1\n  fi\n}\n\nextract_controldata() {\n  cat \u003c\u003c EOF | kubectl exec -i -n \"$CLUSTER_NAMESPACE\" \"$(cat /tmp/current-primary)\" -c \"$PATRONI_CONTAINER_NAME\" \\\n      -- sh -e $SHELL_XTRACE \u003e /tmp/pg_controldata\npg_controldata --pgdata=\"$PG_DATA_PATH\"\nEOF\n  if [ \"$?\" = 0 ]\n  then\n    cat /tmp/pg_controldata | awk -F ':' '{ printf \"%s: %s\\n\", $1, $2 }' | awk '{ $2=$2;print }'| awk -F ': ' '\n          BEGIN { print \"\\n            {\"}\n          {\n            if (NR \u003e 1)\n              printf \",\\n             \\\"%s\\\": \\\"%s\\\"\", $1, $2\n            else\n              printf \"             \\\"%s\\\": \\\"%s\\\"\", $1, $2\n          }\n          END { print \"\\n            }\" }' \u003e /tmp/json_controldata\n  else\n    echo '{}' \u003e /tmp/json_controldata\n    return 1\n  fi\n}\n\nretain_backups() {\n  cat \u003c\u003c EOF | kubectl exec -i -n \"$CLUSTER_NAMESPACE\" \"$(cat /tmp/current-replica-or-primary)\" -c \"$PATRONI_CONTAINER_NAME\" \\\n  -- sh -e $SHELL_XTRACE\n# for each existing backup sorted by backup name ascending (this also mean sorted by creation date ascending)\nexec-with-env \"$BACKUP_ENV\" \\\\\n  -- wal-g backup-list --detail --json \\\\\n  | tr -d '[]' | sed 's/},{/}|{/g' | tr '|' '\\\\n' \\\\\n  | grep '\"backup_name\"' \\\\\n  | sort -r -t , -k 2 \\\\\n  | (RETAIN=\"$RETAIN\"\n    while read BACKUP\n    do\n      BACKUP_NAME=\"\\$(echo \"\\$BACKUP\" | tr -d '{}\\\\42' | tr ',' '\\\\n' \\\\\n          | grep 'backup_name' | cut -d : -f 2-)\"\n      echo \"Check if backup \\$BACKUP_NAME has to be retained and will retain \\$RETAIN backups\"\n      # if is not the created backup and is not in backup CR list, mark as impermanent\n      if [ \"\\$BACKUP_NAME\" != \"$CURRENT_BACKUP_NAME\" ] \\\\\n        \u0026\u0026 ! echo '$(cat /tmp/backups)' \\\\\n        | cut -d : -f 4 \\\\\n        | grep -v '^\\$' \\\\\n        | grep -q \"^\\$BACKUP_NAME\\$\"\n      then\n        if echo \"\\$BACKUP\" | grep -q \"\\\\\"is_permanent\\\\\":true\"\n        then\n          echo \"Mark \\$BACKUP_NAME as impermanent and will retain \\$RETAIN backups\"\n          exec-with-env \"$BACKUP_ENV\" \\\\\n            -- wal-g backup-mark -i \"\\$BACKUP_NAME\"\n        fi\n      # if is inside the retain window, mark as permanent and decrease RETAIN counter\n      elif [ \"\\$RETAIN\" -gt 0 ]\n      then\n        if [ \"\\$BACKUP_NAME\" = \"$CURRENT_BACKUP_NAME\" -a \"$BACKUP_IS_PERMANENT\" != true ] \\\\\n          || echo \"\\$BACKUP\" | grep -q \"\\\\\"is_permanent\\\\\":false\"\n        then\n          echo \"Mark \\$BACKUP_NAME as permanent and will retain \\$((RETAIN-1)) more backups\"\n          exec-with-env \"$BACKUP_ENV\" \\\\\n            -- wal-g backup-mark \"\\$BACKUP_NAME\"\n        fi\n        RETAIN=\"\\$((RETAIN-1))\"\n      # if is outside the retain window...\n      elif [ \"\\$RETAIN\" -le 0 ]\n      then\n        # ... and has a managed lifecycle, mark as impermanent\n        if echo '$(cat /tmp/backups)' \\\\\n          | grep '^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:true' \\\\\n          | cut -d : -f 4 \\\\\n          | grep -v '^\\$' \\\\\n          | grep -q \"^\\$BACKUP_NAME\\$\" \\\\\n          \u0026\u0026 echo \"\\$BACKUP\" | grep -q \"\\\\\"is_permanent\\\\\":true\"\n        then\n          echo \"Mark \\$BACKUP_NAME as impermanent\"\n          exec-with-env \"$BACKUP_ENV\" \\\\\n            -- wal-g backup-mark -i \"\\$BACKUP_NAME\"\n        # ... and has not a managed lifecycle, mark as permanent\n        elif echo '$(cat /tmp/backups)' \\\\\n          | grep -v '^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:true' \\\\\n          | cut -d : -f 4 \\\\\n          | grep -v '^\\$' \\\\\n          | grep -q \"^\\$BACKUP_NAME\\$\" \\\\\n          \u0026\u0026 echo \"\\$BACKUP\" | grep -q \"\\\\\"is_permanent\\\\\":false\"\n        then\n          echo \"Mark \\$BACKUP_NAME as permanent\"\n          exec-with-env \"$BACKUP_ENV\" \\\\\n            -- wal-g backup-mark \"\\$BACKUP_NAME\"\n        fi\n      fi\n    done)\n\n# removes all backups that are marked as impermanent\necho \"Cleaning up impermanent backups\"\nexec-with-env \"$BACKUP_ENV\" \\\\\n  -- wal-g delete retain FIND_FULL \"0\" --confirm\n\n# for each existing backup\nexec-with-env \"$BACKUP_ENV\" \\\\\n  -- wal-g backup-list --detail --json \\\\\n  | tr -d '[]' | sed 's/},{/}|{/g' | tr '|' '\\\\n' \\\\\n  | grep '\"backup_name\"' \\\\\n  | while read BACKUP\n    do\n      BACKUP_NAME=\"\\$(echo \"\\$BACKUP\" | tr -d '{}\\\\42' | tr ',' '\\\\n' \\\\\n          | grep 'backup_name' | cut -d : -f 2-)\"\n      echo \"Check if backup \\$BACKUP_NAME has to be set permanent or impermanent\"\n      # if is the created backup and has a managed lifecycle, mark as impermanent\n      if [ \"\\$BACKUP_NAME\" = \"$CURRENT_BACKUP_NAME\" -a \"$BACKUP_IS_PERMANENT\" != true ] \\\\\n        || (echo '$(cat /tmp/backups)' \\\\\n        | grep '^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:true' \\\\\n        | cut -d : -f 4 \\\\\n        | grep -v '^\\$' \\\\\n        | grep -q \"^\\$BACKUP_NAME\\$\" \\\\\n        \u0026\u0026 echo \"\\$BACKUP\" | grep -q \"\\\\\"is_permanent\\\\\":true\")\n      then\n        echo \"Mark \\$BACKUP_NAME as impermanent\"\n        exec-with-env \"$BACKUP_ENV\" \\\\\n          -- wal-g backup-mark -i \"\\$BACKUP_NAME\"\n      # if has not a managed lifecycle, mark as permanent\n      elif echo '$(cat /tmp/backups)' \\\\\n        | grep -v '^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:true' \\\\\n        | cut -d : -f 4 \\\\\n        | grep -v '^\\$' \\\\\n        | grep -q \"^\\$BACKUP_NAME\\$\" \\\\\n        \u0026\u0026 echo \"\\$BACKUP\" | grep -q \"\\\\\"is_permanent\\\\\":false\"\n      then\n        echo \"Mark \\$BACKUP_NAME as permanent\"\n        exec-with-env \"$BACKUP_ENV\" \\\\\n          -- wal-g backup-mark \"\\$BACKUP_NAME\"\n      fi\n    done\nEOF\n}\n\nlist_backups() {\n  cat \u003c\u003c EOF | kubectl exec -i -n \"$CLUSTER_NAMESPACE\" \"$(cat /tmp/current-replica-or-primary)\" -c \"$PATRONI_CONTAINER_NAME\" \\\n    -- sh -e $SHELL_XTRACE \u003e /tmp/backup-list\nWALG_LOG_LEVEL= exec-with-env \"$BACKUP_ENV\" \\\\\n-- wal-g backup-list --detail --json\nEOF\n  cat /tmp/backup-list | tr -d '[]' | sed 's/},{/}|{/g' | tr '|' '\\n' \\\n    | grep '\"backup_name\"' \\\n    \u003e /tmp/existing-backups\n}\n\nset_backup_completed() {\n  EXISTING_BACKUP_IS_PERMANENT=\"$(grep \"^is_permanent:\" /tmp/current-backup | cut -d : -f 2-)\"\n  IS_BACKUP_SUBJECT_TO_RETENTION_POLICY=\"\"\n  if [ \"$EXISTING_BACKUP_IS_PERMANENT\" = \"true\" ]\n  then\n    IS_BACKUP_SUBJECT_TO_RETENTION_POLICY=\"false\"\n  else\n    IS_BACKUP_SUBJECT_TO_RETENTION_POLICY=\"true\"\n  fi\n\n  BACKUP_PATCH='[\n    {\"op\":\"replace\",\"path\":\"/status/internalName\",\"value\":\"'\"$CURRENT_BACKUP_NAME\"'\"},\n    {\"op\":\"replace\",\"path\":\"/status/process/status\",\"value\":\"'\"$BACKUP_PHASE_COMPLETED\"'\"},\n    {\"op\":\"replace\",\"path\":\"/status/process/failure\",\"value\":\"\"},\n    {\"op\":\"replace\",\"path\":\"/status/process/managedLifecycle\",\"value\":'$IS_BACKUP_SUBJECT_TO_RETENTION_POLICY'},\n    {\"op\":\"replace\",\"path\":\"/status/process/timing\",\"value\":{\n        \"stored\":\"'\"$(grep \"^time:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"start\":\"'\"$(grep \"^start_time:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"end\":\"'\"$(grep \"^finish_time:\" /tmp/current-backup | cut -d : -f 2-)\"'\"\n      }\n    },\n    {\"op\":\"replace\",\"path\":\"/status/backupInformation\",\"value\":{\n        \"startWalFile\":\"'\"$(grep \"^wal_file_name:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"timeline\":\"'\"$(grep \"^wal_file_name:\" /tmp/current-backup | cut -d : -f 2- | awk '{startWal=substr($0, 0, 9); timeline=startWal+0; print timeline}')\"'\",\n        \"hostname\":\"'\"$(grep \"^hostname:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"sourcePod\":\"'\"$(grep \"^hostname:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"pgData\":\"'\"$(grep \"^data_dir:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"postgresVersion\":\"'\"$(grep \"^pg_version:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"systemIdentifier\":\"'\"$(grep \"^system_identifier:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n        \"lsn\":{\n          \"start\":\"'\"$(grep \"^start_lsn:\" /tmp/current-backup | cut -d : -f 2-)\"'\",\n          \"end\":\"'\"$(grep \"^finish_lsn:\" /tmp/current-backup | cut -d : -f 2-)\"'\"\n        },\n        \"size\":{\n          \"uncompressed\":'\"$(grep \"^uncompressed_size:\" /tmp/current-backup | cut -d : -f 2-)\"',\n          \"compressed\":'\"$(grep \"^compressed_size:\" /tmp/current-backup | cut -d : -f 2-)\"'\n        },\n        \"controlData\": '\"$(cat /tmp/json_controldata)\"'\n      }\n    }\n  ]'\n  kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_NAME\" --type json --patch \"$BACKUP_PATCH\"\n}\n\nreconcile_backup_crs() {\n  kubectl get pod -n \"$CLUSTER_NAMESPACE\" \\\n    --template=\"{{ range .items }}{{ .metadata.name }}{{ printf \"'\"\\n\"'\" }}{{ end }}\" \\\n    \u003e /tmp/pods\n  for BACKUP in $(cat /tmp/backups)\n  do\n    BACKUP_CR_NAME=\"$(echo \"$BACKUP\" | cut -d : -f 2)\"\n    BACKUP_PHASE=\"$(echo \"$BACKUP\" | cut -d : -f 3)\"\n    BACKUP_NAME=\"$(echo \"$BACKUP\" | cut -d : -f 4)\"\n    BACKUP_POD=\"$(echo \"$BACKUP\" | cut -d : -f 5)\"\n    BACKUP_SHEDULED_BACKUP=\"$(echo \"$BACKUP\" | cut -d : -f 6)\"\n    BACKUP_MANAGED_LIFECYCLE=\"$(echo \"$BACKUP\" | cut -d : -f 8)\"\n    BACKUP_IS_PERMANENT=\"$([ \"$BACKUP_MANAGED_LIFECYCLE\" = true ] \u0026\u0026 echo false || echo true)\"\n    BACKUP_CONFIG=\"$(kubectl get \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CR_NAME\" \\\n      --template=\"{{ .status.sgBackupConfig.storage }}\")\"\n    # if backup CR has backup internal name, is marked as completed, uses the same current\n    # backup config but is not found in the storage, delete it\n    if [ -n \"$BACKUP_NAME\" ] \u0026\u0026 [ \"$BACKUP_PHASE\" = \"$BACKUP_PHASE_COMPLETED\" ] \\\n      \u0026\u0026 [ \"$BACKUP_CONFIG\" = \"$CURRENT_BACKUP_CONFIG\" ] \\\n      \u0026\u0026 ! grep -q \"\\\"backup_name\\\":\\\"$BACKUP_NAME\\\"\" /tmp/existing-backups\n    then\n      echo \"Deleting backup CR $BACKUP_CR_NAME since backup does not exists\"\n      kubectl delete \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CR_NAME\"\n    # if backup CR is a scheduled backup, is marked as running, has no pod or pod\n    # has been terminated, delete it\n    elif [ \"$BACKUP_SHEDULED_BACKUP\" = \"$RIGHT_VALUE\" ] \\\n      \u0026\u0026 [ \"$BACKUP_PHASE\" = \"$BACKUP_PHASE_RUNNING\" ] \\\n      \u0026\u0026 ([ -z \"$BACKUP_POD\" ] || ! grep -q \"^$BACKUP_POD$\" /tmp/pods)\n    then\n      echo \"Deleting backup CR $BACKUP_CR_NAME since backup is running but pod does not exists\"\n      kubectl delete \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CR_NAME\"\n    # if backup CR has backup internal name, is marked as completed, and is marked as\n    # stored as not managed lifecycle or managed lifecycle and is found as managed lifecycle or\n    # not managed lifecycle respectively, then mark it as stored as managed lifecycle or\n    # not managed lifecycle respectively\n    elif [ -n \"$BACKUP_NAME\" ] \u0026\u0026 [ \"$BACKUP_PHASE\" = \"$BACKUP_PHASE_COMPLETED\" ] \\\n      \u0026\u0026 ! grep \"\\\"backup_name\\\":\\\"$BACKUP_NAME\\\"\" /tmp/existing-backups \\\n        | grep -q \"\\\"is_permanent\\\":$BACKUP_IS_PERMANENT\"\n    then\n      EXISTING_BACKUP_IS_PERMANENT=\"$(grep \"\\\"backup_name\\\":\\\"$BACKUP_NAME\\\"\" /tmp/existing-backups \\\n        | tr -d '{}\"' | tr ',' '\\n' | grep \"^is_permanent:\" | cut -d : -f 2-)\"\n      IS_BACKUP_SUBJECT_TO_RETENTION_POLICY=\"\"\n      if [ \"$EXISTING_BACKUP_IS_PERMANENT\" = \"true\" ]\n      then\n        IS_BACKUP_SUBJECT_TO_RETENTION_POLICY=\"false\"\n      else\n        IS_BACKUP_SUBJECT_TO_RETENTION_POLICY=\"true\"\n      fi\n      echo \"Updating backup CR $BACKUP_CR_NAME .status.process.managedLifecycle to $IS_BACKUP_SUBJECT_TO_RETENTION_POLICY since was updated in the backup\"\n      kubectl patch \"$BACKUP_CRD_NAME\" -n \"$CLUSTER_NAMESPACE\" \"$BACKUP_CR_NAME\" --type json --patch '[\n        {\"op\":\"replace\",\"path\":\"/status/process/managedLifecycle\",\"value\":'$IS_BACKUP_SUBJECT_TO_RETENTION_POLICY'}\n        ]'\n    fi\n  done\n}\n\nrun\n",
    "exec-with-env": "#!/bin/sh\n\nset -e\n\ndie() {\n  \u003e\u00262 echo \"$@\"\n  exit 1\n}\n\nREPLACES=\"\"\nOVERWRITE=false\n\nwhile [ \"$#\" -gt 0 ]\ndo\n  case \"$1\" in\n  -r|--replace)\n    shift\n    if [ -z \"$REPLACES\" ]\n    then\n      REPLACES=\"$1\"\n    else\n      REPLACES=\"$REPLACES,$1\"\n    fi\n    shift\n    ;;\n  -o|--overwrite)\n    shift\n    OVERWRITE=true\n    ;;\n  --)\n    shift\n    break\n    ;;\n  *)\n    if echo \"$1\" | grep -q \"^/\"\n    then\n      plain_envdir=\"$1\"\n      secret_envdir=\"\"\n      [ -d \"$plain_envdir\" ] \\\n        || die \"$plain_envdir is not a directory\"\n    else\n      secret_envdir=\"${BASE_SECRET_PATH}/$1\"\n      plain_envdir=\"${BASE_ENV_PATH}/$1\"\n      [ -d \"$plain_envdir\" -o -d \"$secret_envdir\" ] \\\n        || die \"None of $plain_envdir or $secret_envdir is a directory\"\n    fi\n    shift\n    for envdir in \"$plain_envdir\" \"$secret_envdir\"\n    do\n      [ -d \"$envdir\" ] || continue\n      # When md5sum of values of environment variables ordered alphabetically (excluding variable\n      # MD5SUM) does not match variable MD5SUM we fail since in transition state\n      [ \"$(ls -1a \"$envdir\" | grep -v \"^MD5SUM$\" \\\n        | while read envvar; do [ ! -f \"$envdir/$envvar\" ] || cat \"$envdir/$envvar\"; done \\\n        | md5sum | cut -d ' ' -f 1 | tr 'a-z' 'A-Z')\" = \"$(cat \"$envdir/MD5SUM\")\" ] \\\n        || die \"Environment variable in transient state\"\n      for envvar in $(ls -1a \"$envdir\")\n      do\n        # Only export if \"$envdir/$envvar\" is a file\n        # and environment variable with name $envvar is not set\n        [ ! -f \"$envdir/$envvar\" ] || [ \"$OVERWRITE\" != \"true\" -a -n \"$(eval \"echo \\\"\\$$envvar\\\"\")\" ] \\\n          || eval \"export $envvar='$(cat \"$envdir/$envvar\")'\"\n      done\n    done\n    ;;\n  esac\ndone\n\nif [ -n \"$REPLACES\" ]\nthen\n  for REPLACE in $(echo \"$REPLACES\" | tr ',' '\\n')\n  do\n    eval \"export ${REPLACE%=*}=\\\"\\$${REPLACE#*=}\\\"\"\n  done\nfi\n\nif [ -n \"$1\" ]\nthen\n  exec \"$@\"\nfi\n",
    "group": "root:x:0:\nbin:x:1:\ndaemon:x:2:\nsys:x:3:\nadm:x:4:\ntty:x:5:\ndisk:x:6:\nlp:x:7:\nmem:x:8:\nkmem:x:9:\nwheel:x:10:\ncdrom:x:11:\nmail:x:12:\nman:x:15:\ndialout:x:18:\nfloppy:x:19:\ngames:x:20:\ntape:x:33:\nvideo:x:39:\nftp:x:50:\nlock:x:54:\naudio:x:63:\nusers:x:100:\nnobody:x:65534:\n",
    "gshadow": "root:::\nbin:::\ndaemon:::\nsys:::\nadm:::\ntty:::\ndisk:::\nlp:::\nmem:::\nkmem:::\nwheel:::\ncdrom:::\nmail:::\nman:::\ndialout:::\nfloppy:::\ngames:::\ntape:::\nvideo:::\nftp:::\nlock:::\naudio:::\nusers:::\nnobody:::\n",
    "passwd": "root:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\ngames:x:12:100:games:/usr/games:/sbin/nologin\nftp:x:14:50:FTP User:/var/ftp:/sbin/nologin\n",
    "post-init.sh": "#!/bin/bash\nset -e\nIFS=$'\\n'\nINIT_SCRIPT_PATH=/etc/patroni/init-script.d\n\n# check if path exist\nif [ -d \"$INIT_SCRIPT_PATH\" -a \"$(ls -1 \"$INIT_SCRIPT_PATH\" 2\u003e/dev/null|wc -l)\" -ge 1 ]\nthen\n  for FILE in $(ls -1 \"$INIT_SCRIPT_PATH\")\n  do\n    FILE=\"$(realpath \"$INIT_SCRIPT_PATH/$FILE\")\"\n    if [ \"${FILE: -3}\" == \".sh\" -a -f \"$FILE\" ]\n    then\n      echo \"Executing shell script $FILE\"\n      bash \"$FILE\"\n      echo \"Shell script $FILE executed\"\n    fi\n  done\n  # search for .sql file and execute them\n  for FILE in $(ls -1 \"$INIT_SCRIPT_PATH\" | sort -n -t -)\n  do\n    FILE=\"$(realpath \"$INIT_SCRIPT_PATH/$FILE\")\"\n    if [ \"${FILE: -4}\" == \".sql\" -a -f \"$FILE\" ]\n    then\n      DATABASE=\"$([ \"$(basename \"$FILE\" | tr '.' '\\n' | wc -l)\" -gt 2 ] \\\n        \u0026\u0026 echo \"$(basename \"$FILE\" | tr '.' '\\n' | tail -n 2 | head -n -1 | tr '\\n' '.')\" \\\n        || echo postgres)\"\n      DATABASE=\"${DATABASE%.}\"\n      echo \"Executing SQL script $FILE for DATABASE $DATABASE with user postgres on port ${POSTGRES_PORT}\"\n      cat \"$FILE\" | python3 -c \"$(cat \u003c\u003c EOF\nimport psycopg2,sys\nconnection = psycopg2.connect(\"user=postgres dbname='$DATABASE' port=${POSTGRES_PORT}\")\nconnection.autocommit = True\ncursor = connection.cursor()\ncursor.execute(sys.stdin.read())\ntry: print(cursor.fetchall())\nexcept: print()\nEOF\n)\"\n      echo \"Shell SQL $FILE executed\"\n    fi\n  done\nfi\n",
    "setup-arbitrary-user.sh": "#!/bin/sh\n\nUSER=postgres\nUID=\"$(id -u)\"\nGID=\"$(id -g)\"\nSHELL=/bin/sh\ncp \"$TEMPLATES_PATH/passwd\" /local/etc/.\ncp \"$TEMPLATES_PATH/group\" /local/etc/.\ncp \"$TEMPLATES_PATH/shadow\" /local/etc/.\ncp \"$TEMPLATES_PATH/gshadow\" /local/etc/.\necho \"$USER:x:$UID:$GID::$PG_BASE_PATH:$SHELL\" \u003e\u003e /local/etc/passwd\nchmod 644 /local/etc/passwd\necho \"$USER:x:$GID:\" \u003e\u003e /local/etc/group\nchmod 644 /local/etc/group\necho \"$USER\"':!!:18179:0:99999:7:::' \u003e\u003e /local/etc/shadow\nchmod 000 /local/etc/shadow\necho \"$USER\"':!::' \u003e\u003e /local/etc/gshadow\nchmod 000 /local/etc/gshadow\n",
    "setup-data-paths.sh": "#!/bin/sh\n\nmkdir -p \"$PG_DATA_PATH\"\nchmod -R 700 \"$PG_DATA_PATH\"\n",
    "setup-scripts.sh": "#!/bin/sh\n\ncp \"$TEMPLATES_PATH/start-patroni.sh\" \"$LOCAL_BIN_PATH\"\ncp \"$TEMPLATES_PATH/start-patroni-with-restore.sh\" \"$LOCAL_BIN_PATH\"\ncp \"$TEMPLATES_PATH/post-init.sh\" \"$LOCAL_BIN_PATH\"\ncp \"$TEMPLATES_PATH/exec-with-env\" \"$LOCAL_BIN_PATH\"\nsed -i \"s#\\${POSTGRES_PORT}#${POSTGRES_PORT}#g\" \\\n  \"$LOCAL_BIN_PATH/post-init.sh\"\nsed -i \"s#\\${BASE_ENV_PATH}#${BASE_ENV_PATH}#g\" \\\n  \"$LOCAL_BIN_PATH/exec-with-env\"\nsed -i \"s#\\${BASE_SECRET_PATH}#${BASE_SECRET_PATH}#g\" \\\n  \"$LOCAL_BIN_PATH/exec-with-env\"\nchmod a+x \"$LOCAL_BIN_PATH/start-patroni.sh\"\nchmod a+x \"$LOCAL_BIN_PATH/start-patroni-with-restore.sh\"\nchmod a+x \"$LOCAL_BIN_PATH/post-init.sh\"\nchmod a+x \"$LOCAL_BIN_PATH/exec-with-env\"\n",
    "shadow": "root:!locked::0:99999:7:::\nbin:*:18199:0:99999:7:::\ndaemon:*:18199:0:99999:7:::\nadm:*:18199:0:99999:7:::\nlp:*:18199:0:99999:7:::\nsync:*:18199:0:99999:7:::\nshutdown:*:18199:0:99999:7:::\nhalt:*:18199:0:99999:7:::\nmail:*:18199:0:99999:7:::\noperator:*:18199:0:99999:7:::\ngames:*:18199:0:99999:7:::\nftp:*:18199:0:99999:7:::\nnobody:*:18199:0:99999:7:::\n",
    "shell-utils": "#!/bin/sh\n\nLOCK_TIMEOUT=\"${LOCK_TIMEOUT:-60}\"\nLOCK_SLEEP=\"${LOCK_SLEEP:-5}\"\n\nSHELL=\"$(readlink /proc/$$/exe)\"\nif [ \"$(basename \"$SHELL\")\" = busybox ]\nthen\n  SHELL=sh\nfi\nSHELL_XTRACE=$(! echo $- | grep -q x || echo \" -x\")\n\nacquire_lock() {\n  try_lock true\n}\n\nmaintain_lock() {\n  while true\n  do\n    sleep \"$LOCK_SLEEP\"\n    try_lock false\n    if [ \"$?\" != 0 ]\n    then\n      return 1\n    fi\n  done\n}\n\ntry_lock() {\n  if [ -z \"$CLUSTER_NAMESPACE\" -o -z \"$POD_NAME\" -o -z \"$LOCK_RESOURCE\" -o -z \"$LOCK_RESOURCE_NAME\" ]\n  then\n    echo \"CLUSTER_NAMESPACE, POD_NAME, LOCK_RESOURCE and LOCK_RESOURCE_NAME environmant variables must be defined\"\n    return 1\n  fi\n  local AQUIRE=\"$1\"\n  local TEMPLATE='\n  LOCK_POD={{ if .metadata.annotations.lockPod }}{{ .metadata.annotations.lockPod }}{{ else }}{{ end }}\n  LOCK_TIMESTAMP={{ if .metadata.annotations.lockTimestamp }}{{ .metadata.annotations.lockTimestamp }}{{ else }}0{{ end }}\n  RESOURCE_VERSION={{ .metadata.resourceVersion }}\n  '\n  kubectl get \"$LOCK_RESOURCE\" -n \"$CLUSTER_NAMESPACE\" \"$LOCK_RESOURCE_NAME\" --template=\"$TEMPLATE\" \u003e /tmp/lock-resource\n  . /tmp/lock-resource\n  CURRENT_TIMESTAMP=\"$(date +%s)\"\n  if [ \"$POD_NAME\" != \"$LOCK_POD\" ]\n  then\n    if \"$AQUIRE\"\n    then\n      if [ \"$((CURRENT_TIMESTAMP-LOCK_TIMESTAMP))\" -lt \"$LOCK_TIMEOUT\" ]\n      then\n        local WAIT_DURATION=\"$((LOCK_TIMEOUT + LOCK_SLEEP))\"\n        echo \"Locked already by $LOCK_POD at $(date -d @\"$LOCK_TIMESTAMP\" -Iseconds --utc), will retry in $WAIT_DURATION seconds\"\n        sleep \"$WAIT_DURATION\"\n        try_lock true\n      fi\n    else\n      echo \"Locked already by $LOCK_POD at $(date -d @\"$LOCK_TIMESTAMP\" -Iseconds --utc)\"\n      return 1\n    fi\n  else\n    if ! \"$AQUIRE\" \u0026\u0026 [ \"$((CURRENT_TIMESTAMP-LOCK_TIMESTAMP))\" -gt \"$LOCK_TIMEOUT\" ]\n    then\n      echo \"Lock expired!\"\n      return 1\n    fi\n  fi\n  if ! kubectl annotate \"$LOCK_RESOURCE\" -n \"$CLUSTER_NAMESPACE\" \"$LOCK_RESOURCE_NAME\" \\\n    --resource-version \"$RESOURCE_VERSION\" --overwrite \"lockPod=$POD_NAME\" \"lockTimestamp=$CURRENT_TIMESTAMP\"\n  then\n    kubectl get \"$LOCK_RESOURCE\" -n \"$CLUSTER_NAMESPACE\" \"$LOCK_RESOURCE_NAME\" --template=\"$TEMPLATE\" \u003e /tmp/lock-resource\n    . /tmp/lock-resource\n    if [ \"$POD_NAME\" = \"$LOCK_POD\" ]\n    then\n      try_lock \"$AQUIRE\"\n      return 0\n    fi\n    echo \"Locked by $LOCK_POD at $(date -d @\"$LOCK_TIMESTAMP\" -Iseconds --utc)\"\n    if \"$AQUIRE\"\n    then\n      sleep \"$((LOCK_SLEEP * 4))\"\n      try_lock true\n    else\n      return 1\n    fi\n  fi\n}\n\nrelease_lock() {\n  if [ -z \"$CLUSTER_NAMESPACE\" -o -z \"$POD_NAME\" -o -z \"$LOCK_RESOURCE\" -o -z \"$LOCK_RESOURCE_NAME\" ]\n  then\n    echo \"CLUSTER_NAMESPACE, POD_NAME, LOCK_RESOURCE and LOCK_RESOURCE_NAME environmant variables must be defined\"\n    return 1\n  fi\n  local TEMPLATE='\n  LOCK_POD={{ if .metadata.annotations.lockPod }}{{ .metadata.annotations.lockPod }}{{ else }}{{ end }}\n  LOCK_TIMESTAMP={{ if .metadata.annotations.lockTimestamp }}{{ .metadata.annotations.lockTimestamp }}{{ else }}0{{ end }}\n  RESOURCE_VERSION={{ .metadata.resourceVersion }}\n  '\n  kubectl get \"$LOCK_RESOURCE\" -n \"$CLUSTER_NAMESPACE\" \"$LOCK_RESOURCE_NAME\" --template=\"$TEMPLATE\" \u003e /tmp/lock-resource\n  . /tmp/lock-resource\n  if [ \"$POD_NAME\" != \"$LOCK_POD\" ]\n  then\n    return 0\n  fi\n  if ! kubectl annotate \"$LOCK_RESOURCE\" -n \"$CLUSTER_NAMESPACE\" \"$LOCK_RESOURCE_NAME\" \\\n    --resource-version \"$RESOURCE_VERSION\" --overwrite \"lockPod=\" \"lockTimestamp=0\"\n  then\n    kubectl get \"$LOCK_RESOURCE\" -n \"$CLUSTER_NAMESPACE\" \"$LOCK_RESOURCE_NAME\" --template=\"$TEMPLATE\" \u003e /tmp/lock-resource\n    . /tmp/lock-resource\n    if [ \"$POD_NAME\" = \"$LOCK_POD\" ]\n    then\n      release_lock\n    fi\n    return 0\n  fi\n}\n\nto_json_string() {\n  sed ':a;N;$!ba;s/\\n/\\\\n/g' | sed 's/\\([\"\\\\\\t]\\)/\\\\\\1/g' | tr '\\t' 't'\n}\n\nkill_with_childs() {\n  (\n  set +e\n  local PID=\"$1\"\n  local SPIDS=\"x\"\n  local OPIDS\n  OPIDS=\"$PID\"\n  local OPPID=\"$OPIDS\"\n  while [ -n \"$OPPID\" ]\n  do\n      OPPID=\"$(grep '^PPid:[[:space:]]'\"\\($(\n            echo \"$OPPID\" | sed '{s/ $//;s/ /\\\\|/g}'\n          )\\)\"'$' /proc/[0-9]*/status 2\u003e/dev/null \\\n        | cut -d / -f 3 | tr '\\n' ' ')\"\n      OPIDS=\"$OPIDS $OPPID\"\n  done\n  kill -13 $OPIDS 2\u003e/dev/null || true\n  )\n}\n\nkill_session_siblings() {\n  (\n  set +e\n  local PID=\"$(exec \"$SHELL\" -c 'echo $PPID')\"\n  local NSSID=\"$(grep '^NSsid:[[:space:]]' \"/proc/$PID/status\" \\\n        | tr -d '[:space:]' | cut -d : -f 2)\"\n  local SPIDS=\"x\"\n  local OPIDS\n  OPIDS=\"$PID\"\n  local OPPID=\"$OPIDS\"\n  while [ \"$OPPID\" != \"$NSSID\" ]\n  do\n      OPPID=\"$(grep '^PPid:[[:space:]]' \"/proc/$OPPID/status\" \\\n        | tr -d '[:space:]' | cut -d : -f 2)\"\n      OPIDS=\"$OPIDS $OPPID\"\n  done\n  while [ \"$SPIDS\" = x ] \\\n    || [ \"$(ls -d $(echo \"$SPIDS\" | sed 's#\\([0-9]\\+\\) #/proc/\\1 #g') 2\u003e\u00261 | grep -i 'no such' | wc -l)\" \\\n      -lt \"$(echo \"$SPIDS\" | wc -w)\" ]\n  do\n    test \"$SPIDS\" = \"x\" || kill -13 $SPIDS 2\u003e/dev/null || true\n    SPIDS=\"$(grep '^NSsid:[[:space:]]'\"$NSSID\"'$' /proc/[0-9]*/status 2\u003e/dev/null \\\n      | cut -d / -f 3 | grep -v '^'\"\\($(echo \"$OPIDS\" | sed 's/ /\\\\|/g')\\)\"'$' | tr '\\n' ' ')\"\n  done\n  ) || true\n}\n\ntrap_callback() {\n  kill_session_siblings\n}\n\ntrap_callback_and_exit() {\n  trap_callback\n  exit \"$1\"\n}\n\nset_trap() {\n  trap 'trap_callback_and_exit $?' HUP INT QUIT PIPE TERM ABRT\n  trap 'trap_callback $?' EXIT\n}\n",
    "start-patroni-with-restore.sh": "export PATRONI_POSTGRESQL_LISTEN=\"$(eval \"echo $PATRONI_POSTGRESQL_LISTEN\")\"\nexport PATRONI_POSTGRESQL_CONNECT_ADDRESS=\"$(eval \"echo $PATRONI_POSTGRESQL_CONNECT_ADDRESS\")\"\nexport PATRONI_RESTAPI_CONNECT_ADDRESS=\"$(eval \"echo $PATRONI_RESTAPI_CONNECT_ADDRESS\")\"\nexport HOME=\"$PG_BASE_PATH\"\n\ncat \u003c\u003c 'EOF' | exec-with-env \"${RESTORE_ENV}\" -- sh -ex\nif [ -n \"$ENDPOINT_HOSTNAME\" ] \u0026\u0026 [ -n \"$ENDPOINT_PORT\" ]\nthen\n  if cat \u003c /dev/null \u003e \"/dev/tcp/$ENDPOINT_HOSTNAME/$ENDPOINT_PORT\"\n  then\n    echo \"Host $ENDPOINT_HOSTNAME:$ENDPOINT_PORT reachable\"\n  else\n    echo \"ERROR: Host $ENDPOINT_HOSTNAME:$ENDPOINT_PORT not reachable\"\n    exit 1\n  fi\nfi\nEOF\n\ncat \u003c\u003c EOF \u003e \"$PATRONI_CONFIG_PATH/postgres.yml\"\nscope: ${PATRONI_SCOPE}\nname: ${PATRONI_NAME}\n\nbootstrap:\n  post_init: '${LOCAL_BIN_PATH}/post-init.sh'\n  method: wal_g\n  wal_g:\n    command: '${PATRONI_CONFIG_PATH}/bootstrap'\n    keep_existing_recovery_conf: False\n    recovery_conf:\n      restore_command: 'exec-with-env \"${RESTORE_ENV}\" -- wal-g wal-fetch %f %p'\n      recovery_target_timeline: 'latest'\n      recovery_target_action: 'promote'\n  initdb:\n  - auth-host: md5\n  - auth-local: trust\n  - encoding: UTF8\n  - locale: C.UTF-8\n  - data-checksums\n  pg_hba:\n  - 'host all all 0.0.0.0/0 md5'\n  - 'host replication ${PATRONI_REPLICATION_USERNAME} 0.0.0.0/0 md5'\nrestapi:\n  connect_address: '${PATRONI_KUBERNETES_POD_IP}:8008'\n  listen: 0.0.0.0:8008\npostgresql:\n  use_pg_rewind: true\n  remove_data_directory_on_rewind_failure: true\n  use_unix_socket: true\n  connect_address: '${PATRONI_KUBERNETES_POD_IP}:5432'\n  listen: 0.0.0.0:5432\n  authentication:\n    superuser:\n      password: '${PATRONI_SUPERUSER_PASSWORD}'\n    replication:\n      password: '${PATRONI_REPLICATION_PASSWORD}'\n  parameters:\n    unix_socket_directories: '${PATRONI_POSTGRES_UNIX_SOCKET_DIRECTORY}'\n  basebackup:\n    checkpoint: 'fast'\nwatchdog:\n  mode: off\nEOF\n\ncat \u003c\u003c EOF \u003e \"$PATRONI_CONFIG_PATH/bootstrap\"\n#!/bin/sh\n\nexec-with-env \"$RESTORE_ENV\" \\\\\n  -- sh -ec 'wal-g backup-fetch \"\\$PG_DATA_PATH\" \"\\$RESTORE_BACKUP_ID\"'\nEOF\nchmod a+x \"$PATRONI_CONFIG_PATH/bootstrap\"\n\nexport LC_ALL=C.UTF-8\n\nunset PATRONI_SUPERUSER_PASSWORD PATRONI_REPLICATION_PASSWORD\n\nexec /usr/bin/patroni \"$PATRONI_CONFIG_PATH/postgres.yml\"\n",
    "start-patroni.sh": "export PATRONI_POSTGRESQL_LISTEN=\"$(eval \"echo $PATRONI_POSTGRESQL_LISTEN\")\"\nexport PATRONI_POSTGRESQL_CONNECT_ADDRESS=\"$(eval \"echo $PATRONI_POSTGRESQL_CONNECT_ADDRESS\")\"\nexport PATRONI_RESTAPI_CONNECT_ADDRESS=\"$(eval \"echo $PATRONI_RESTAPI_CONNECT_ADDRESS\")\"\nexport HOME=\"$PG_BASE_PATH\"\n\ncat \u003c\u003c EOF \u003e \"$PATRONI_CONFIG_PATH/postgres.yml\"\nscope: ${PATRONI_SCOPE}\nname: ${PATRONI_NAME}\n\nbootstrap:\n  post_init: '${LOCAL_BIN_PATH}/post-init.sh'\n  initdb:\n  - auth-host: md5\n  - auth-local: trust\n  - encoding: UTF8\n  - locale: C.UTF-8\n  - data-checksums\n  pg_hba:\n  - 'host all all 0.0.0.0/0 md5'\n  - 'host replication ${PATRONI_REPLICATION_USERNAME} 0.0.0.0/0 md5'\nrestapi:\n  connect_address: '${PATRONI_KUBERNETES_POD_IP}:8008'\n  listen: 0.0.0.0:8008\npostgresql:\n  use_pg_rewind: true\n  remove_data_directory_on_rewind_failure: true\n  use_unix_socket: true\n  connect_address: '${PATRONI_KUBERNETES_POD_IP}:5432'\n  listen: 0.0.0.0:5432\n  authentication:\n    superuser:\n      password: '${PATRONI_SUPERUSER_PASSWORD}'\n    replication:\n      password: '${PATRONI_REPLICATION_PASSWORD}'\n  parameters:\n    unix_socket_directories: '${PATRONI_POSTGRES_UNIX_SOCKET_DIRECTORY}'\n  basebackup:\n    checkpoint: 'fast'\nwatchdog:\n  mode: off\nEOF\n\nexport LC_ALL=C.UTF-8\n\nunset PATRONI_SUPERUSER_PASSWORD PATRONI_REPLICATION_PASSWORD\n\nexec /usr/bin/patroni \"$PATRONI_CONFIG_PATH/postgres.yml\"\n"
  },
  "kind": "ConfigMap",
  "metadata": {
    "creationTimestamp": "2021-06-04T19:51:35Z",
    "labels": {
      "app": "StackGresDistributedLogs",
      "distributed-logs-name": "distributedlogs",
      "distributed-logs-uid": "194a581e-4f62-486e-8fa7-9b1effca98bf"
    },
    "name": "distributedlogs-templates",
    "namespace": "operator-upgrade-60ba8257",
    "ownerReferences": [
      {
        "apiVersion": "stackgres.io/v1beta1",
        "controller": true,
        "kind": "SGDistributedLogs",
        "name": "distributedlogs",
        "uid": "194a581e-4f62-486e-8fa7-9b1effca98bf"
      }
    ],
    "resourceVersion": "5468",
    "selfLink": "/api/v1/namespaces/operator-upgrade-60ba8257/configmaps/distributedlogs-templates",
    "uid": "715d21b1-038b-42fd-bb1f-a376a2d53904"
  }
}
