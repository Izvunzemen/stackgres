pg_replication:
  master: true
  query: "SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())) as lag, CASE WHEN pg_is_in_recovery() THEN 1 ELSE 0 END as is_replica"
  metrics:
    - lag:
        usage: "GAUGE"
        description: "Replication lag behind master in seconds"
    - is_replica:
        usage: "GAUGE"
        description: "Indicates if this host is a replica"

pg_postmaster:
  master: true
  query: "SELECT pg_postmaster_start_time as start_time_seconds from pg_postmaster_start_time()"
  metrics:
    - start_time_seconds:
        usage: "GAUGE"
        description: "Time at which postmaster started"

pg_stat_user_tables:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, COALESCE(last_vacuum, ''1970-01-01Z'') as last_vacuum, COALESCE(last_autovacuum, ''1970-01-01Z'') as last_autovacuum, COALESCE(last_analyze, ''1970-01-01Z'') as last_analyze, COALESCE(last_autoanalyze, ''1970-01-01Z'') as last_autoanalyze, vacuum_count, autovacuum_count, analyze_count, autoanalyze_count FROM pg_catalog.pg_stat_user_tables')
        AS (schemaname name, relname name, seq_scan bigint, seq_tup_read bigint, idx_scan bigint, idx_tup_fetch bigint, n_tup_ins bigint, n_tup_upd bigint, n_tup_del bigint, n_tup_hot_upd bigint, n_live_tup bigint, n_dead_tup bigint, n_mod_since_analyze bigint, last_vacuum timestamp with time zone, last_autovacuum timestamp with time zone, last_analyze timestamp with time zone, last_autoanalyze timestamp with time zone, vacuum_count bigint, autovacuum_count bigint, analyze_count bigint, autoanalyze_count bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of current database"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - seq_scan:
        usage: "COUNTER"
        description: "Number of sequential scans initiated on this table"
    - seq_tup_read:
        usage: "COUNTER"
        description: "Number of live rows fetched by sequential scans"
    - idx_scan:
        usage: "COUNTER"
        description: "Number of index scans initiated on this table"
    - idx_tup_fetch:
        usage: "COUNTER"
        description: "Number of live rows fetched by index scans"
    - n_tup_ins:
        usage: "COUNTER"
        description: "Number of rows inserted"
    - n_tup_upd:
        usage: "COUNTER"
        description: "Number of rows updated"
    - n_tup_del:
        usage: "COUNTER"
        description: "Number of rows deleted"
    - n_tup_hot_upd:
        usage: "COUNTER"
        description: "Number of rows HOT updated (i.e., with no separate index update required)"
    - n_live_tup:
        usage: "GAUGE"
        description: "Estimated number of live rows"
    - n_dead_tup:
        usage: "GAUGE"
        description: "Estimated number of dead rows"
    - n_mod_since_analyze:
        usage: "GAUGE"
        description: "Estimated number of rows changed since last analyze"
    - last_vacuum:
        usage: "GAUGE"
        description: "Last time at which this table was manually vacuumed (not counting VACUUM FULL)"
    - last_autovacuum:
        usage: "GAUGE"
        description: "Last time at which this table was vacuumed by the autovacuum daemon"
    - last_analyze:
        usage: "GAUGE"
        description: "Last time at which this table was manually analyzed"
    - last_autoanalyze:
        usage: "GAUGE"
        description: "Last time at which this table was analyzed by the autovacuum daemon"
    - vacuum_count:
        usage: "COUNTER"
        description: "Number of times this table has been manually vacuumed (not counting VACUUM FULL)"
    - autovacuum_count:
        usage: "COUNTER"
        description: "Number of times this table has been vacuumed by the autovacuum daemon"
    - analyze_count:
        usage: "COUNTER"
        description: "Number of times this table has been manually analyzed"
    - autoanalyze_count:
        usage: "COUNTER"
        description: "Number of times this table has been analyzed by the autovacuum daemon"

pg_statio_user_tables:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read, tidx_blks_hit FROM pg_catalog.pg_statio_user_tables')
        AS (schemaname name, relname name, heap_blks_read bigint, heap_blks_hit bigint, idx_blks_read bigint, idx_blks_hit bigint, toast_blks_read bigint, toast_blks_hit bigint, tidx_blks_read bigint, tidx_blks_hit bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of current database"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - heap_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table"
    - heap_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table"
    - idx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from all indexes on this table"
    - idx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in all indexes on this table"
    - toast_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table's TOAST table (if any)"
    - toast_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table's TOAST table (if any)"
    - tidx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table's TOAST table indexes (if any)"
    - tidx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table's TOAST table indexes (if any)"

pg_database:
  master: true
  query: "SELECT pg_database.datname, pg_database_size(pg_database.datname) as size FROM pg_catalog.pg_database"
  cache_seconds: 30
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database"
    - size_bytes:
        usage: "GAUGE"
        description: "Disk space used by the database"

pg_archiver:
  master: true
  query: |
    WITH
      current_wal_file AS (
         SELECT CASE WHEN NOT pg_is_in_recovery() THEN pg_walfile_name(pg_last_wal_replay_lsn()) ELSE NULL END pg_walfile_name
      ),
      current_wal AS (
        SELECT
          ('x'||substring(pg_walfile_name,9,8))::bit(32)::int log,
          ('x'||substring(pg_walfile_name,17,8))::bit(32)::int seg,
          pg_walfile_name
        FROM current_wal_file
      ),
      archive_wal AS(
        SELECT
          ('x'||substring(last_archived_wal,9,8))::bit(32)::int log,
          ('x'||substring(last_archived_wal,17,8))::bit(32)::int seg,
          last_archived_wal
        FROM pg_catalog.pg_stat_archiver
      )
    SELECT coalesce(((cw.log - aw.log) * 256) + (cw.seg-aw.seg),'NaN'::float) as pending_wal_count FROM current_wal cw, archive_wal aw 
  metrics:
    - pending_wal_count:
        usage: "GAUGE"
        description: "No. of pending WAL files to be archived"

pg_stat_user_indexes:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch FROM pg_catalog.pg_stat_user_indexes')
        AS (schemaname name, relname name, indexrelname name, idx_scan bigint, idx_tup_read bigint, idx_tup_fetch bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of the table for this index"
    - indexrelname:
        usage: "LABEL"
        description: "Name of this index"
    - idx_scan:
        usage: "COUNTER"
        description: "Number of index scans initiated on this index"
    - idx_tup_read:
        usage: "COUNTER"
        description: "Number of index entries returned by scans on this index"
    - idx_tup_fetch:
        usage: "COUNTER"
        description: "Number of live table rows fetched by simple index scans using this index"

pg_statio_user_indexes:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit FROM pg_catalog.pg_statio_user_indexes')
        AS (schemaname name, relname name, indexrelname name, idx_blks_read bigint, idx_blks_hit bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of the table for this index"
    - indexrelname:
        usage: "LABEL"
        description: "Name of this index"
    - idx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this index"
    - idx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this index"

pg_total_relation_size:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT relnamespace::regnamespace as schemaname, relname as relname, pg_total_relation_size(oid) bytes FROM pg_catalog.pg_class WHERE relkind = ''r''')
        AS (schemaname name, relname name, bytes bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - bytes:
        usage: "GAUGE"
        description: "Total disk space usage for the specified table and associated indexes"

pg_blocked:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT oid, datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT
      locktype AS type,
      NULL AS datname,
      NULL AS schemaname,
      NULL AS reltype,
      NULL AS relname,
      count(*) AS queries
    FROM pg_catalog.pg_locks blocked
    WHERE NOT blocked.granted AND relation IS NULL
    GROUP BY locktype
    UNION
    SELECT
      locktype AS type,
      datname,
      schemaname,
      CASE relkind
        WHEN 'r' THEN 'ordinary table'
        WHEN 'i' THEN 'index'
        WHEN 'S' THEN 'sequence'
        WHEN 't' THEN 'TOAST table'
        WHEN 'v' THEN 'view'
        WHEN 'm' THEN 'materialized view'
        WHEN 'c' THEN 'composite type'
        WHEN 'f' THEN 'foreign table'
        WHEN 'p' THEN 'partitioned table'
        WHEN 'I' THEN 'partitioned index'
        ELSE 'unknown type ''' || relkind || ''''
        END AS reltype,
      relname,
      count(*) AS queries
    FROM pg_catalog.pg_locks blocked
    INNER JOIN databases
      ON blocked.database = databases.oid,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT nspname as schemaname, relkind, relname FROM pg_catalog.pg_class LEFT JOIN pg_catalog.pg_namespace ON (pg_namespace.oid = relnamespace) WHERE pg_class.oid = ' || blocked.relation)
        AS (schemaname name, relkind char, relname name)) AS ss
    WHERE NOT blocked.granted AND relation IS NOT NULL
    GROUP BY locktype, datname, schemaname, reltype, relname
  metrics:
    - type:
        usage: "LABEL"
        description: "The lock type"
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "The schema on which a query is blocked"
    - reltype:
        usage: "LABEL"
        description: "The type of relation"
    - relname:
        usage: "LABEL"
        description: "The relation on which a query is blocked"
    - queries:
        usage: "GAUGE"
        description: "The current number of blocked queries"

pg_oldest_blocked:
  master: true
  query: |
    SELECT datname,
      coalesce(extract('epoch' from max(clock_timestamp() - state_change)), 0) age_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE wait_event_type = 'Lock'
    AND state='active'
    GROUP BY datname
  metrics:
    - age_seconds:
        usage: "GAUGE"
        description: "Largest number of seconds any transaction is currently waiting on a lock"
    - datname:
        usage: "LABEL"
        description: "Database name"

pg_slow:
  master: true
  query: |
    SELECT datname, COUNT(*) AS queries
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'active' AND (now() - query_start) > '1 seconds'::interval
    GROUP BY datname;
  metrics:
    - queries:
        usage: "GAUGE"
        description: "Current number of slow queries"
    - datname:
        usage: "LABEL"
        description: "Database name"

pg_long_running_transactions:
  master: true
  query: |
    SELECT datname, COUNT(*) as transactions,
    MAX(EXTRACT(EPOCH FROM (clock_timestamp() - xact_start))) AS age_in_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE state is distinct from 'idle' AND (now() - xact_start) > '1 minutes'::interval AND query not like '%VACUUM%'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "Current number of long running transactions"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum transaction age in seconds"

pg_vacuum:
  master: true
  query: |
    SELECT
      datname,
      COUNT(*) AS queries,
      MAX(EXTRACT(EPOCH FROM (clock_timestamp() - query_start))) AS age_in_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'active' AND trim(query) ~* '\AVACUUM (?!ANALYZE)'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "The current number of VACUUM queries"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum VACUUM query age in seconds"

pg_vacuum_analyze:
  master: true
  query: |
    SELECT
      datname,
      COUNT(*) AS queries,
      MAX(EXTRACT(EPOCH FROM (clock_timestamp() - query_start))) AS age_in_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'active' AND trim(query) ~* '\AVACUUM ANALYZE'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "The current number of VACUUM ANALYZE queries"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum VACUUM ANALYZE query age in seconds"

pg_stuck_idle_in_transaction:
  master: true
  query: |
    SELECT datname,
      COUNT(*) AS queries
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'idle in transaction' AND (now() - query_start) > '10 minutes'::interval
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "Current number of queries that are stuck being idle in transactions"

pg_txid:
  master: true
  query: |
    SELECT
      CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() % (2^52)::bigint END AS current,
      CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_snapshot_xmin(txid_current_snapshot()) % (2^52)::bigint END AS xmin,
      CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() - txid_snapshot_xmin(txid_current_snapshot()) END AS xmin_age
  metrics:
    - current:
        usage: "COUNTER"
        description: "Current 64-bit transaction id of the query used to collect this metric (truncated to low 52 bits)"
    - xmin:
        usage: "COUNTER"
        description: "Oldest transaction id of a transaction still in progress, i.e. not known committed or aborted (truncated to low 52 bits)"
    - xmin_age:
        usage: "GAUGE"
        description: "Age of oldest transaction still not committed or aborted measured in transaction ids"

pg_database_datfrozenxid:
  master: true
  query: "SELECT datname, age(datfrozenxid) AS age FROM pg_catalog.pg_database"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - age:
        usage: "GAUGE"
        description: "Age of the oldest transaction that has not been frozen."

pg_wal_position:
  master: true
  query: |
    SELECT CASE
           WHEN pg_is_in_recovery()
           THEN (pg_last_wal_receive_lsn() - '0/0') % (2^52)::bigint
           ELSE (pg_current_wal_lsn() - '0/0') % (2^52)::bigint
           END AS bytes
  metrics:
    - bytes:
        usage: "COUNTER"
        description: "Postgres LSN (log sequence number) being generated on primary or replayed on replica (truncated to low 52 bits)"


pg_replication_slots:
  master: true
  query: |
    SELECT slot_name, slot_type,
           case when active then 1.0 else 0.0 end AS active,
           age(xmin) AS xmin_age,
           age(catalog_xmin) AS catalog_xmin_age,
           CASE WHEN pg_is_in_recovery() THEN pg_last_wal_receive_lsn() ELSE pg_current_wal_lsn() END - restart_lsn AS restart_lsn_bytes,
           CASE WHEN pg_is_in_recovery() THEN pg_last_wal_receive_lsn() ELSE pg_current_wal_lsn() END - confirmed_flush_lsn AS confirmed_flush_lsn_bytes
      FROM pg_catalog.pg_replication_slots
  metrics:
    - slot_name:
        usage: "LABEL"
        description: "Slot Name"
    - slot_type:
        usage: "LABEL"
        description: "Slot Type"
    - active:
        usage: "GAUGE"
        description: "Boolean flag indicating whether this slot has a consumer streaming from it"
    - xmin_age:
        usage: "GAUGE"
        description: "Age of oldest transaction that cannot be vacuumed due to this replica"
    - catalog_xmin_age:
        usage: "GAUGE"
        description: "Age of oldest transaction that cannot be vacuumed from catalogs due to this replica (used by logical replication)"
    - restart_lsn_bytes:
        usage: "GAUGE"
        description: "Amount of data on in xlog that must be this replica may need to complete recovery"
    - confirmed_flush_lsn_bytes:
        usage: "GAUGE"
        description: "Amount of data on in xlog that must be this replica has not yet received"

pg_stat_ssl:
  master: true
  query: |
    SELECT pid, bits,
           CASE WHEN ssl THEN 1.0 ELSE 0.0 END AS active,
           CASE WHEN compression THEN 1.0 ELSE 0.0 END AS compression
           FROM pg_catalog.pg_stat_ssl
  metrics:
    - pid:
        usage: "LABEL"
        description: "Process ID of a backend or WAL sender process"
    - active:
        usage: "GAUGE"
        description: "Boolean flag indicating if SSL is used on this connection"
    - bits:
        usage: "GAUGE"
        description: "Number of bits in the encryption algorithm is in use"
    - compression:
        usage: "GAUGE"
        description: "Boolean flag indicating if SSL compression is in use"

pg_table_bloat:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
    LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        '-- https://github.com/ioguix/pgsql-bloat-estimation' || E'\n'
        || ' SELECT schemaname, tablename, bs*tblpages AS real_size,' || E'\n'
        || ' (tblpages-est_tblpages)*bs AS extra_size,' || E'\n'
        || ' CASE WHEN tblpages - est_tblpages > 0' || E'\n'
        || '     THEN 100 * (tblpages - est_tblpages)/tblpages::float' || E'\n'
        || '     ELSE 0' || E'\n'
        || ' END AS extra_ratio, fillfactor,' || E'\n'
        || ' CASE WHEN tblpages - est_tblpages_ff > 0' || E'\n'
        || '     THEN (tblpages-est_tblpages_ff)*bs' || E'\n'
        || '     ELSE 0' || E'\n'
        || ' END AS bloat_size,' || E'\n'
        || ' CASE WHEN tblpages - est_tblpages_ff > 0' || E'\n'
        || '     THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float' || E'\n'
        || '     ELSE 0' || E'\n'
        || ' END AS bloat_ratio, is_na' || E'\n'
        || ' FROM (' || E'\n'
        || ' SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,' || E'\n'
        || '     ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,' || E'\n'
        || '     tblpages, fillfactor, bs, tblid, schemaname, tablename, heappages, toastpages, is_na' || E'\n'
        || ' FROM (' || E'\n'
        || '     SELECT' || E'\n'
        || '     ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)' || E'\n'
        || '         - CASE WHEN tpl_hdr_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END' || E'\n'
        || '         - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END' || E'\n'
        || '     ) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,' || E'\n'
        || '     toastpages, reltuples, toasttuples, bs, page_hdr, tblid, schemaname, tablename, fillfactor, is_na' || E'\n'
        || '     FROM (' || E'\n'
        || '     SELECT' || E'\n'
        || '         tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tablename, tbl.reltuples,' || E'\n'
        || '         tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,' || E'\n'
        || '         coalesce(toast.reltuples, 0) AS toasttuples,' || E'\n'
        || '         coalesce(substring(' || E'\n'
        || '         array_to_string(tbl.reloptions, '' '')' || E'\n'
        || '         FROM ''fillfactor=([0-9]+)'')::smallint, 100) AS fillfactor,' || E'\n'
        || '         current_setting(''block_size'')::numeric AS bs,' || E'\n'
        || '         CASE WHEN version()~''mingw32'' OR version()~''64-bit|x86_64|ppc64|ia64|amd64'' THEN 8 ELSE 4 END AS ma,' || E'\n'
        || '         24 AS page_hdr,' || E'\n'
        || '         23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END' || E'\n'
        || '         + CASE WHEN bool_or(att.attname = ''oid'' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,' || E'\n'
        || '         sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,' || E'\n'
        || '         bool_or(att.atttypid = ''pg_catalog.name''::regtype)' || E'\n'
        || '         OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na' || E'\n'
        || '     FROM pg_attribute AS att' || E'\n'
        || '         JOIN pg_class AS tbl ON att.attrelid = tbl.oid' || E'\n'
        || '         JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace' || E'\n'
        || '         LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname' || E'\n'
        || '         AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname' || E'\n'
        || '         LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid' || E'\n'
        || '     WHERE NOT att.attisdropped' || E'\n'
        || '         AND tbl.relkind in (''r'',''m'')' || E'\n'
        || '     GROUP BY 1,2,3,4,5,6,7,8,9,10' || E'\n'
        || '     ORDER BY 2,3' || E'\n'
        || '     ) AS s' || E'\n'
        || ' ) AS s2' || E'\n'
        || ' ) AS s3' || E'\n'
        || ' where schemaname not in (''information_schema'',''pg_catalog'')' || E'\n'
        || ' ORDER BY schemaname, tablename' || E'\n')
       As (schemaname character varying, tablename character varying, real_size numeric, extra_size numeric, extra_ratio numeric, fillfactor numeric, bloat_size numeric, bloat_ratio numeric, is_na boolean)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - schemaname:
        usage: "LABEL"
        description: "Schema Name"
    - tablename:
        usage: "LABEL"
        description: "Table Name"
    - real_size:
        usage: "GAUGE"
        description: "Table real size"
    - extra_size:
        usage: "GAUGE"
        description: "Estimated extra size not used/needed in the table. This extra size is composed by the fillfactor, bloat and alignment padding spaces"
    - extra_ratio:
        usage: "GAUGE"
        description: "Estimated ratio of the real size used by extra_size"
    - fillfactor:
        usage: "GAUGE"
        description: "Table fillfactor"
    - bloat_size:
        usage: "GAUGE"
        description: "Estimated size of the bloat without the extra space kept for the fillfactor."
    - bloat_ratio:
        usage: "GAUGE"
        description: "Estimated ratio of the real size used by bloat_size"
    - is_na:
        usage: "GAUGE"
        description: "Estimation not aplicable, If true, do not trust the stats"

pg_index:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
    LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        '-- https://github.com/ioguix/pgsql-bloat-estimation' || E'\n'
      || ' SELECT nspname AS schema_name, tblname, idxname, bs*(relpages)::bigint AS real_size,' || E'\n'
      || '  bs*(relpages-est_pages)::bigint AS extra_size,' || E'\n'
      || '  100 * (relpages-est_pages)::float / relpages AS extra_ratio,' || E'\n'
      || '  fillfactor,' || E'\n'
      || '  CASE WHEN relpages > est_pages_ff' || E'\n'
      || '  THEN bs*(relpages-est_pages_ff)' || E'\n'
      || '  ELSE 0' || E'\n'
      || '  END AS bloat_size,' || E'\n'
      || '  100 * (relpages-est_pages_ff)::float / relpages AS bloat_ratio,' || E'\n'
      || '  is_na' || E'\n'
      || '  FROM (' || E'\n'
      || '  SELECT coalesce(1 +' || E'\n'
      || '          ceil(reltuples/floor((bs-pageopqdata-pagehdr)/(4+nulldatahdrwidth)::float)), 0' || E'\n'
      || '      ) AS est_pages,' || E'\n'
      || '      coalesce(1 +' || E'\n'
      || '          ceil(reltuples/floor((bs-pageopqdata-pagehdr)*fillfactor/(100*(4+nulldatahdrwidth)::float))), 0' || E'\n'
      || '      ) AS est_pages_ff,' || E'\n'
      || '      bs, nspname, tblname, idxname, relpages, fillfactor, is_na' || E'\n'
      || '  FROM (' || E'\n'
      || '      SELECT maxalign, bs, nspname, tblname, idxname, reltuples, relpages, idxoid, fillfactor,' || E'\n'
      || '          ( index_tuple_hdr_bm +' || E'\n'
      || '              maxalign - CASE -- Add padding to the index tuple header to align on MAXALIGN' || E'\n'
      || '                  WHEN index_tuple_hdr_bm%maxalign = 0 THEN maxalign' || E'\n'
      || '                  ELSE index_tuple_hdr_bm%maxalign' || E'\n'
      || '              END' || E'\n'
      || '              + nulldatawidth + maxalign - CASE -- Add padding to the data to align on MAXALIGN' || E'\n'
      || '                  WHEN nulldatawidth = 0 THEN 0' || E'\n'
      || '                  WHEN nulldatawidth::integer%maxalign = 0 THEN maxalign' || E'\n'
      || '                  ELSE nulldatawidth::integer%maxalign' || E'\n'
      || '              END' || E'\n'
      || '          )::numeric AS nulldatahdrwidth, pagehdr, pageopqdata, is_na' || E'\n'
      || '      FROM (' || E'\n'
      || '          SELECT n.nspname, i.tblname, i.idxname, i.reltuples, i.relpages,' || E'\n'
      || '              i.idxoid, i.fillfactor, current_setting(''block_size'')::numeric AS bs,' || E'\n'
      || '              CASE' || E'\n'
      || '              WHEN version() ~ ''mingw32'' OR version() ~ ''64-bit|x86_64|ppc64|ia64|amd64'' THEN 8' || E'\n'
      || '              ELSE 4' || E'\n'
      || '              END AS maxalign,' || E'\n'
      || '              24 AS pagehdr,' || E'\n'
      || '              16 AS pageopqdata,' || E'\n'
      || '              CASE WHEN max(coalesce(s.null_frac,0)) = 0' || E'\n'
      || '                  THEN 2 -- IndexTupleData size' || E'\n'
      || '                  ELSE 2 + (( 32 + 8 - 1 ) / 8)' || E'\n'
      || '              END AS index_tuple_hdr_bm,' || E'\n'
      || '              sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS nulldatawidth,' || E'\n'
      || '              max( CASE WHEN i.atttypid = ''pg_catalog.name''::regtype THEN 1 ELSE 0 END ) > 0 AS is_na' || E'\n'
      || '          FROM (' || E'\n'
      || '              SELECT ct.relname AS tblname, ct.relnamespace, ic.idxname, ic.attpos, ic.indkey, ic.indkey[ic.attpos], ic.reltuples, ic.relpages, ic.tbloid, ic.idxoid, ic.fillfactor,' || E'\n'
      || '                  coalesce(a1.attnum, a2.attnum) AS attnum, coalesce(a1.attname, a2.attname) AS attname, coalesce(a1.atttypid, a2.atttypid) AS atttypid,' || E'\n'
      || '                  CASE WHEN a1.attnum IS NULL' || E'\n'
      || '                  THEN ic.idxname' || E'\n'
      || '                  ELSE ct.relname' || E'\n'
      || '                  END AS attrelname' || E'\n'
      || '              FROM (' || E'\n'
      || '                  SELECT idxname, reltuples, relpages, tbloid, idxoid, fillfactor, indkey,' || E'\n'
      || '                      pg_catalog.generate_series(1,indnatts) AS attpos' || E'\n'
      || '                  FROM (' || E'\n'
      || '                      SELECT ci.relname AS idxname, ci.reltuples, ci.relpages, i.indrelid AS tbloid,' || E'\n'
      || '                          i.indexrelid AS idxoid,' || E'\n'
      || '                          coalesce(substring(' || E'\n'
      || '                              array_to_string(ci.reloptions, '' '')' || E'\n'
      || '                              from ''fillfactor=([0-9]+)'')::smallint, 90) AS fillfactor,' || E'\n'
      || '                          i.indnatts,' || E'\n'
      || '                          pg_catalog.string_to_array(pg_catalog.textin(' || E'\n'
      || '                              pg_catalog.int2vectorout(i.indkey)),'' '')::int[] AS indkey' || E'\n'
      || '                      FROM pg_catalog.pg_index i' || E'\n'
      || '                      JOIN pg_catalog.pg_class ci ON ci.oid = i.indexrelid' || E'\n'
      || '                      WHERE ci.relam=(SELECT oid FROM pg_am WHERE amname = ''btree'')' || E'\n'
      || '                      AND ci.relpages > 0' || E'\n'
      || '                  ) AS idx_data' || E'\n'
      || '              ) AS ic' || E'\n'
      || '              JOIN pg_catalog.pg_class ct ON ct.oid = ic.tbloid' || E'\n'
      || '              LEFT JOIN pg_catalog.pg_attribute a1 ON' || E'\n'
      || '                  ic.indkey[ic.attpos] <> 0' || E'\n'
      || '                  AND a1.attrelid = ic.tbloid' || E'\n'
      || '                  AND a1.attnum = ic.indkey[ic.attpos]' || E'\n'
      || '              LEFT JOIN pg_catalog.pg_attribute a2 ON' || E'\n'
      || '                  ic.indkey[ic.attpos] = 0' || E'\n'
      || '                  AND a2.attrelid = ic.idxoid' || E'\n'
      || '                  AND a2.attnum = ic.attpos' || E'\n'
      || '          ) i' || E'\n'
      || '          JOIN pg_catalog.pg_namespace n ON n.oid = i.relnamespace' || E'\n'
      || '          JOIN pg_catalog.pg_stats s ON s.schemaname = n.nspname' || E'\n'
      || '                                      AND s.tablename = i.attrelname' || E'\n'
      || '                                      AND s.attname = i.attname' || E'\n'
      || '          GROUP BY 1,2,3,4,5,6,7,8,9,10,11' || E'\n'
      || '      ) AS rows_data_stats' || E'\n'
      || '  ) AS rows_hdr_pdg_stats' || E'\n'
      || '  ) AS relation_stats' || E'\n'
      || '  WHERE nspname != ''pg_catalog'' ' || E'\n'
      || '  ORDER BY nspname, tblname, idxname;' || E'\n')
      As (schema_name character varying, tblname character varying, idxname character varying, real_size numeric, extra_size numeric, extra_ratio numeric, fillfactor numeric, bloat_size numeric, bloat_ratio numeric, is_na boolean)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - schema_name:
        usage: "LABEL"
        description: "Schema Name"
    - tblname:
        usage: "LABEL"
        description: "Table Name"
    - idxname:
        usage: "LABEL"
        description: "Index Name"
    - real_size:
        usage: "GAUGE"
        description: "Index size"
    - extra_size:
        usage: "GAUGE"
        description: "Index extra size"
    - extra_ratio:
        usage: "GAUGE"
        description: "Index extra size ratio"
    - fillfactor:
        usage: "GAUGE"
        description: "Fillfactor"
    - bloat_size:
        usage: "GAUGE"
        description: "Estimate index bloat size"
    - bloat_ratio:
        usage: "GAUGE"
        description: "Estimate index bloat size ratio"
    - is_na:
        usage: "GAUGE"
        description: "Estimate Not aplicable, bad statistic"

pg_replication_status:
  master: true
  query: |
    select application_name,
    client_addr,
    state,
    pg_wal_lsn_diff(pg_stat_replication.sent_lsn, pg_stat_replication.replay_lsn) AS lag_size
    FROM pg_stat_replication;
  metrics:
    - application_name:
        usage: "LABEL"
        description: "Application or node name"
    - client_addr:
        usage: "LABEL"
        description: "Client ip address"
    - state:
        usage: "LABEL"
        description: "Client replication state"
    - lag_size_bytes:
        usage: "GAUGE"
        description: "Replication lag size in bytes"

# PGBOUNCER QUERIES

pgbouncer_show_clients:
  master: true
  query: |
    SELECT _.type,
    _."user",
    _.database,
    _.state,
    _.addr,
    _.port,
    _.local_addr,
    _.local_port,
    _.connect_time,
    _.request_time,
    _.wait,
    _.wait_us,
    _.close_needed,
    _.ptr,
    _.link,
    _.remote_pid,
    _.tls
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show clients'::text)
    _(type text, "user" text, database text, state text, addr text, port integer, local_addr text, local_port integer,
    connect_time timestamp with time zone, request_time timestamp with time zone, wait integer, wait_us integer, close_needed integer,
    ptr text, link text, remote_pid integer, tls text);
  metrics:
    - type:
        usage: "LABEL"
        description: "C, for client."
    - user:
        usage: "LABEL"
        description: "Client connected user"
    - database:
        usage: "LABEL"
        description: "Database name"
    - state:
        usage: "LABEL"
        description: "State of the client connection, one of active or waiting"
    - addr:
        usage: "LABEL"
        description: "IP address of client"
    - port:
        usage: "GAUGE"
        description: "Port client is connected to"
    - local_addr:
        usage: "LABEL"
        description: "Connection end address on local machine"
    - local_port:
        usage: "GAUGE"
        description: "Connection end port on local machine"
    - connect_time:
        usage: "LABEL"
        description: "Timestamp of connect time"
    - request_time:
        usage: "LABEL"
        description: "Timestamp of latest client request"
    - wait:
        usage: "GAUGE"
        description: "Current waiting time in seconds"
    - wait_us:
        usage: "GAUGE"
        description: "Microsecond part of the current waiting time"
    - close_needed:
        usage: "GAUGE"
        description: "not used for clients"
    - ptr:
        usage: "LABEL"
        description: "Address of internal object for this connection. Used as unique ID"
    - link:
        usage: "LABEL"
        description: "Address of server connection the client is paired with"
    - remote_pid:
        usage: "GAUGE"
        description: "Process ID, in case client connects over Unix socket and OS supports getting it"
    - tls:
        usage: "LABEL"
        description: "A string with TLS connection information, or empty if not using TLS"

pgbouncer_show_pools:
  master: true
  query: |
    SELECT _.database,
    _."user",
    _.cl_active,
    _.cl_waiting,
    _.sv_active,
    _.sv_idle,
    _.sv_used,
    _.sv_tested,
    _.sv_login,
    _.maxwait,
    _.maxwait_us,
    _.pool_mode
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show pools'::text)
    _(database text, "user" text, cl_active integer, cl_waiting integer, sv_active integer, sv_idle integer,
    sv_used integer, sv_tested integer, sv_login integer, maxwait integer, maxwait_us integer, pool_mode text);
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - user:
        usage: "LABEL"
        description: "User name"
    - cl_active:
        usage: "GAUGE"
        description: "Client connections that are linked to server connection and can process queries"
    - cl_waiting:
        usage: "GAUGE"
        description: "Client connections that have sent queries but have not yet got a server connection"
    - sv_active:
        usage: "GAUGE"
        description: "Server connections that are linked to a client"
    - sv_idle:
        usage: "GAUGE"
        description: "Server connections that are unused and immediately usable for client queries"
    - sv_used:
        usage: "GAUGE"
        description: "Server connections that have been idle for more than server_check_delay so they need server_check_query to run on them"
    - sv_tested:
        usage: "GAUGE"
        description: "Server connections that are currently running either server_reset_query or server_check_query"
    - sv_login:
        usage: "GAUGE"
        description: "Server connections currently in the process of logging in"
    - maxwait:
        usage: "GAUGE"
        description: "How long the first oldest client in the queue has waited, in seconds"
    - maxwait_us:
        usage: "GAUGE"
        description: "Microsecond part of the maximum waiting time"
    - pool_mode:
        usage: "LABEL"
        description: "The pooling mode in use"

pgbouncer_show_databases:
  master: true
  query: |
    select _.name,
    _.host,
    _.port,
    _.database,
    _.force_user,
    _.pool_size,
    _.reserve_pool,
    _.pool_mode,
    _.max_connections,
    _.current_connections,
    _.paused,
    _.disabled
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show databases'::text)
    _(name text, host text, port integer, database text, force_user text, pool_size integer, reserve_pool integer,
    pool_mode text, max_connections integer, current_connections integer, paused boolean, disabled boolean);
  metrics:
    - name:
        usage: "LABEL"
        description: "Name of configured database entry"
    - host:
        usage: "LABEL"
        description: "Host pgbouncer connects to"
    - port:
        usage: "GAUGE"
        description: "Port pgbouncer connects to"
    - database:
        usage: "LABEL"
        description: "Actual database name pgbouncer connects to."
    - force_user:
        usage: "LABEL"
        description: "When the user is part of the connection string the connection between pgbouncer and PostgreSQL is forced to the given user"
    - pool_size:
        usage: "GAUGE"
        description: "Maximum number of server connections"
    - reserve_pool:
        usage: "GAUGE"
        description: "Maximum number of additional connections for this database"
    - pool_mode:
        usage: "LABEL"
        description: "The database override pool_mode"
    - max_connections:
        usage: "GAUGE"
        description: "Maximum number of allowed connections for this database"
    - current_connections:
        usage: "GAUGE"
        description: "Current number of connections for this database"
    - paused:
        usage: "GAUGE"
        description: "1 if this database is currently paused, else 0"
    - disabled:
        usage: "GAUGE"
        description: "1 if this database is currently paused, else 0"

pgbouncer_show_stats_totals:
  master: true
  query: |
    select _.database,
    _.xact_count,
    _.query_count,
    _.bytes_received,
    _.bytes_sent,
    _.xact_time,
    _.query_time,
    _.wait_time
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show stats_totals'::text)
    _(database text, xact_count bigint, query_count bigint, bytes_received bigint, bytes_sent bigint, xact_time bigint,
    query_time bigint, wait_time bigint);
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - xact_count:
        usage: "GAUGE"
        description: "Number of SQL transactions pooled"
    - query_count:
        usage: "GAUGE"
        description: "Number of SQL queries pooled"
    - bytes_received:
        usage: "GAUGE"
        description: "Volume in bytes of network traffic received"
    - bytes_sent:
        usage: "GAUGE"
        description: "Volume in bytes of network traffic sent"
    - xact_time:
        usage: "GAUGE"
        description: "Number of microseconds spent by pgbouncer when connected to PostgreSQL in a transaction"
    - query_time:
        usage: "GAUGE"
        description: "Number of microseconds spent by pgbouncer when actively connected to PostgreSQL"
    - wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds"

pgbouncer_show_stats:
  master: true
  query: |
    select _.database,
    _.total_xact_count,
    _.total_query_count,
    _.total_received,
    _.total_sent,
    _.total_xact_time,
    _.total_query_time,
    _.total_wait_time,
    _.avg_xact_count,
    _.avg_query_count,
    _.avg_recv,
    _.avg_sent,
    _.avg_xact_time,
    _.avg_query_time,
    _.avg_wait_time
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show stats'::text)
    _(database text, total_xact_count bigint, total_query_count bigint, total_received bigint, total_sent bigint,total_xact_time bigint, total_query_time bigint,
    total_wait_time bigint, avg_xact_count bigint, avg_query_count bigint, avg_recv bigint, avg_sent bigint, avg_xact_time bigint, avg_query_time bigint,
    avg_wait_time bigint);
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - total_xact_count:
        usage: "GAUGE"
        description: "Total number of SQL transactions pooled"
    - total_query_count:
        usage: "GAUGE"
        description: "Total number of SQL queries pooled"
    - total_received:
        usage: "GAUGE"
        description: "Total volume in bytes of network traffic received"
    - total_sent:
        usage: "GAUGE"
        description: "Total volume in bytes of network traffic sent"
    - total_xact_time:
        usage: "GAUGE"
        description: "Total number of microseconds spent by pgbouncer when connected to PostgreSQL in a transaction"
    - total_query_time:
        usage: "GAUGE"
        description: "Total number of microseconds spent by pgbouncer when actively connected to PostgreSQL"
    - total_wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds"
    - avg_xact_count:
        usage: "GAUGE"
        description: "Average transactions per second in last stat period"
    - avg_query_count:
        usage: "GAUGE"
        description: "Average queries per second in last stat period"
    - avg_recv:
        usage: "GAUGE"
        description: "Average received from clients bytes per second"
    - avg_sent:
        usage: "GAUGE"
        description: "Average sent to clients bytes per second"
    - avg_xact_time:
        usage: "GAUGE"
        description: "Average transaction duration, in microseconds"
    - avg_query_time:
        usage: "GAUGE"
        description: "Average query duration, in microseconds"
    - avg_wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds average per second"

disk:
  master: true
  query: |
    WITH disk AS (
      SELECT '/var/lib/postgresql/' AS path),
    walwriter AS (
      SELECT pid from pg_stat_activity where backend_type IN ('walwriter', 'walreceiver')) LIMIT 1,
    df AS (
      SELECT df('/proc/' || pid || '/root' || path) AS line FROM walwriter, disk)
    SELECT df[7] AS path, df[2] fs_type, df[3] AS total_size,  df[4] AS user_size, df[5] AS available_size
      FROM (SELECT regexp_split_to_array(line, E'\\s+') AS df FROM df OFFSET 1 LIMIT 1) AS df
  metrics:
    - path:
        usage: "LABEL"
        description: "Mount path of the disk"
    - fs_type:
        usage: "LABEL"
        description: "Filesystem type of the disk"
    - total_size_bytes:
        usage: "GAUGE"
        description: "Total disk size in bytes"
    - used_size_bytes:
        usage: "GAUGE"
        description: "Used disk size in bytes"
    - available_size_bytes:
        usage: "GAUGE"
        description: "Available disk size in bytes"
